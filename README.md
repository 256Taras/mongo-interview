### Загальні питання про MongoDB

1. **Що таке MongoDB і як вона відрізняється від реляційних баз даних?**
   MongoDB — це документно-орієнтована база даних NoSQL, яка використовує документи у форматі BSON (Binary JSON) для зберігання даних. На відміну від реляційних баз даних, MongoDB не використовує традиційні таблиці з рядками і стовпцями. Замість цього вона працює з колекціями документів, які можуть мати різну структуру. Основні відмінності включають:
    - **Схема даних:** MongoDB не потребує попередньо визначеної схеми, що дозволяє гнучко змінювати структуру документів.
    - **Масштабованість:** MongoDB спроектована для горизонтального масштабування за допомогою шардингу.
    - **Використання індексів:** MongoDB підтримує різні види індексів для підвищення продуктивності запитів.
    - **Агрегація:** В MongoDB є потужний фреймворк агрегації для обробки і аналізу даних.
    - **Транзакції:** Починаючи з версії 4.0, MongoDB підтримує багатодокументні транзакції для підтримки ACID властивостей.

2. **Які основні переваги та недоліки використання MongoDB?**
   **Переваги:**
    - **Гнучка схема:** Відсутність жорсткої схеми дозволяє швидко адаптуватися до змін у структурі даних.
    - **Горизонтальне масштабування:** Можливість масштабування за допомогою шардингу для підтримки великих обсягів даних і високих навантажень.
    - **Висока продуктивність:** Висока швидкість запису та читання завдяки оптимізованій внутрішній структурі даних.
    - **Агрегаційний фреймворк:** Потужні інструменти для агрегації та аналізу даних.
    - **Підтримка реплікації:** Підвищена доступність та надійність даних завдяки використанню реплікаційних наборів.

   **Недоліки:**
    - **Відсутність підтримки транзакцій:** Обмежена підтримка багатодокументних транзакцій (докладно з версії 4.0).
    - **Відсутність жорсткої схеми:** Відсутність попередньо визначеної схеми може призвести до несумісності даних і проблем із керуванням схемою.
    - **Високе використання пам’яті:** MongoDB може вимагати більше пам’яті для індексів та обробки великих обсягів даних.
    - **Обмежена підтримка складних запитів:** В деяких випадках складні запити можуть бути менш ефективними у порівнянні з реляційними базами даних.

3. **Що таке документ у MongoDB?**
   Документ у MongoDB — це базова одиниця даних, яка зберігається у колекції. Документи представлені у форматі BSON (Binary JSON), що є двійковою формою JSON, і можуть включати різні типи даних, такі як рядки, числа, дати, масиви та вкладені документи. Документи в одній колекції можуть мати різну структуру, що забезпечує гнучкість у зберіганні даних. Приклад документа:
   ```json
   {
     "_id": ObjectId("507f1f77bcf86cd799439011"),
     "name": "John Doe",
     "email": "john.doe@example.com",
     "age": 29,
     "address": {
       "street": "123 Main St",
       "city": "New York",
       "state": "NY",
       "zip": "10001"
     },
     "hobbies": ["reading", "traveling", "coding"]
   }
   ```
   Документи ідентифікуються унікальним полем `_id`, яке автоматично створюється при вставці, якщо не вказане вручну.

4. **Що таке колекція у MongoDB?**
   Колекція у MongoDB — це набір документів. Вона є аналогом таблиці у реляційних базах даних, але, на відміну від таблиць, колекції не мають фіксованої схеми. Це означає, що документи в одній колекції можуть мати різні структури і поля. Колекції створюються автоматично при вставці першого документа. Приклад створення колекції і вставки документа:
   ```javascript
   db.users.insertOne({
     "name": "Alice",
     "email": "alice@example.com",
     "age": 25
   });
   ```
   Колекції можна використовувати для зберігання різних типів даних і організації їх для ефективного доступу і обробки.

5. **Що таке база даних у MongoDB?**
   База даних у MongoDB — це контейнер для колекцій. Вона організовує і зберігає колекції документів, дозволяючи логічно групувати дані. Кожна база даних має власний набір файлів на файловій системі сервера MongoDB. Бази даних можуть мати різні колекції, а колекції — різні документи. Створення бази даних відбувається автоматично при створенні колекції або вставці першого документа. Приклад створення бази даних і колекції:
   ```javascript
   use mydatabase;
   db.createCollection("users");
   db.users.insertOne({
     "name": "Bob",
     "email": "bob@example.com",
     "age": 32
   });
   ```

11. **Як створити індекс у MongoDB?**
    Індекси в MongoDB створюються за допомогою методу `createIndex()`. Цей метод приймає об'єкт, що визначає поля, які потрібно індексувати, та тип індексації (висхідний або низхідний). Основний синтаксис створення індексу виглядає так:
   ```javascript
   db.collection.createIndex({ field1: 1, field2: -1 });
   ```
У цьому прикладі `field1` буде індексуватися у висхідному порядку (1), а `field2` — у низхідному порядку (-1). Приклади створення індексів:
- **Простий індекс:** Індексування одного поля у висхідному порядку.
  ```javascript
  db.users.createIndex({ email: 1 });
  ```
- **Складений індекс:** Індексування кількох полів.
  ```javascript
  db.orders.createIndex({ customerId: 1, orderDate: -1 });
  ```
- **Унікальний індекс:** Забезпечення унікальності значень у полі.
  ```javascript
  db.products.createIndex({ sku: 1 }, { unique: true });
  ```
- **Текстовий індекс:** Індексування текстових полів для пошуку.
  ```javascript
  db.articles.createIndex({ content: "text" });
  ```
- **Геопросторовий індекс:** Індексування географічних даних.
  ```javascript
  db.locations.createIndex({ coordinates: "2dsphere" });
  ```

12. **Які види індексів підтримує MongoDB?**
    MongoDB підтримує кілька типів індексів, кожен з яких має свої особливості та застосування:
- **Однопольові індекси (Single Field Indexes):** Індекси для одного поля.
  ```javascript
  db.collection.createIndex({ field: 1 });
  ```
- **Складені індекси (Compound Indexes):** Індекси для кількох полів.
  ```javascript
  db.collection.createIndex({ field1: 1, field2: -1 });
  ```
- **Мультіключові індекси (Multikey Indexes):** Індекси для полів, що містять масиви.
  ```javascript
  db.collection.createIndex({ arrayField: 1 });
  ```
- **Текстові індекси (Text Indexes):** Індекси для текстових пошуків.
  ```javascript
  db.collection.createIndex({ field: "text" });
  ```
- **Геопросторові індекси (Geospatial Indexes):** Індекси для географічних даних.
  ```javascript
  db.collection.createIndex({ location: "2dsphere" });
  ```
- **Хешовані індекси (Hashed Indexes):** Індекси для полів, значення яких розподіляються випадково.
  ```javascript
  db.collection.createIndex({ field: "hashed" });
  ```
- **Унікальні індекси (Unique Indexes):** Забезпечують унікальність значень у полі.
  ```javascript
  db.collection.createIndex({ field: 1 }, { unique: true });
  ```
- **Інтервальні індекси (TTL Indexes):** Видаляють документи через заданий час.
  ```javascript
  db.collection.createIndex({ createdAt: 1 }, { expireAfterSeconds: 3600 });
  ```

13. **Що таке складені індекси у MongoDB?**
    Складені індекси у MongoDB — це індекси, які охоплюють кілька полів документа. Вони дозволяють виконувати пошук і сортування на основі кількох критеріїв. При створенні складеного індексу важливо враховувати порядок полів, оскільки він впливає на ефективність запитів. Приклад створення складеного індексу:
   ```javascript
   db.orders.createIndex({ customerId: 1, orderDate: -1 });
   ```
У цьому прикладі індекс буде спочатку сортувати документи за `customerId` у висхідному порядку, а потім за `orderDate` у низхідному порядку. Складені індекси корисні для запитів, які фільтрують або сортують дані за кількома полями. Наприклад:
   ```javascript
   db.orders.find({ customerId: 123 }).sort({ orderDate: -1 });
   ```

14. **Що таке текстові індекси і як вони працюють?**
    Текстові індекси у MongoDB дозволяють виконувати пошук тексту в документах. Вони індексують текстові поля і дозволяють виконувати повнотекстовий пошук з використанням різних операторів. Для створення текстового індексу використовується ключове слово "text":
   ```javascript
   db.articles.createIndex({ content: "text" });
   ```
Після створення текстового індексу можна виконувати пошук за текстовими полями з використанням оператора `$text`:
   ```javascript
   db.articles.find({ $text: { $search: "MongoDB" } });
   ```
Текстові індекси підтримують кілька важливих функцій:
- **Пошук фраз:** Використання лапок для пошуку точної фрази.
  ```javascript
  db.articles.find({ $text: { $search: "\"NoSQL database\"" } });
  ```
- **Виключення слів:** Використання мінусів для виключення слів.
  ```javascript
  db.articles.find({ $text: { $search: "MongoDB -SQL" } });
  ```
- **Пошук з вагами:** Встановлення ваг для різних полів для впливу на релевантність результатів.
  ```javascript
  db.articles.createIndex({ title: "text", content: "text" }, { weights: { title: 10, content: 2 } });
  ```

15. **Що таке геоіндекси у MongoDB?**
    Геоіндекси у MongoDB використовуються для зберігання і запитів географічних даних. Вони дозволяють ефективно обробляти запити, пов'язані з локацією, такими як пошук найближчих точок, області або радіуса. MongoDB підтримує два типи геоіндексів:
- **2d індекси:** Для двовимірних координат (наприклад, плоскі координати).
  ```javascript
  db.places.createIndex({ location: "2d" });
  ```
- **2dsphere індекси:** Для координат на сфері (наприклад, географічні координати).
  ```javascript
  db.places.createIndex({ location: "2dsphere" });
  ```
Приклади використання геоіндексів:
- **Пошук найближчих точок:**
  ```javascript
  db.places.find({ location: { $near: [50, 50] } });
  ```
- **Пошук у радіусі:**
  ```javascript
  db.places.find({ location: { $geoWithin: { $center: [[50, 50], 10] } } });
  ```
- **Пошук у полігоні:**
  ```javascript
  db.places.find({ location: { $geoWithin: { $polygon: [[0, 0], [0, 100], [100, 100], [100, 0], [0, 0]] } } });
  ```

16. **Як перевірити використання індексів у запитах?**
    Для перевірки використання індексів у запитах у MongoDB можна скористатися методом `explain()`. Цей метод показує план виконання запиту, включаючи інформацію про використані індекси. Приклад:
   ```javascript
   db.collection.find({ field: value }).explain("executionStats");
   ```
Результат `explain()` включає кілька корисних полів:
- **queryPlanner:** Інформація про вибір плану виконання запиту.
- **winningPlan:** Деталі плану, який був вибраний для виконання запиту.
- **indexBounds:** Обмеження індексів, використаних у запиті.
- **executionStats:** Статистика виконання запиту, включаючи кількість документів, які були перевірені, і кількість документів, які відповідали запиту.
  Приклад результату `explain()`:
   ```json
   {
     "queryPlanner": {
       "plannerVersion": 1

,
       "namespace": "db.collection",
       "indexFilterSet": false,
       "parsedQuery": { "field": { "$eq": value } },
       "winningPlan": {
         "stage": "FETCH",
         "inputStage": {
           "stage": "IXSCAN",
           "keyPattern": { "field": 1 },
           "indexName": "field_1",
           "isMultiKey": false,
           "multiKeyPaths": { "field": [] },
           "isUnique": false,
           "isSparse": false,
           "isPartial": false,
           "indexVersion": 2,
           "direction": "forward",
           "indexBounds": { "field": [ "[value, value]" ] }
         }
       },
       "rejectedPlans": []
     },
     "executionStats": {
       "executionSuccess": true,
       "nReturned": 1,
       "executionTimeMillis": 1,
       "totalKeysExamined": 1,
       "totalDocsExamined": 1,
       "executionStages": {
         "stage": "FETCH",
         "nReturned": 1,
         "executionTimeMillisEstimate": 0,
         "works": 2,
         "advanced": 1,
         "needTime": 0,
         "needYield": 0,
         "saveState": 0,
         "restoreState": 0,
         "isEOF": 1,
         "docsExamined": 1,
         "alreadyHasObj": 0,
         "inputStage": {
           "stage": "IXSCAN",
           "nReturned": 1,
           "executionTimeMillisEstimate": 0,
           "works": 2,
           "advanced": 1,
           "needTime": 0,
           "needYield": 0,
           "saveState": 0,
           "restoreState": 0,
           "isEOF": 1,
           "keyPattern": { "field": 1 },
           "indexName": "field_1",
           "isMultiKey": false,
           "multiKeyPaths": { "field": [] },
           "isUnique": false,
           "isSparse": false,
           "isPartial": false,
           "indexVersion": 2,
           "direction": "forward",
           "indexBounds": { "field": [ "[value, value]" ] }
         }
       }
     }
   }
   ```

17. **Як видалити індекс у MongoDB?**
   Індекси у MongoDB можна видалити за допомогою методу `dropIndex()`. Цей метод приймає ім'я індексу, яке потрібно видалити. Ім'я індексу можна отримати за допомогою методу `getIndexes()`, який повертає список усіх індексів колекції. Приклад видалення індексу:
   ```javascript
   // Отримати список індексів
   db.collection.getIndexes();
   
   // Видалити індекс за його іменем
   db.collection.dropIndex("field_1");
   ```
Якщо потрібно видалити всі індекси у колекції, за винятком індексу `_id`, можна скористатися методом `dropIndexes()`:
   ```javascript
   db.collection.dropIndexes();
   ```
Важливо пам'ятати, що видалення індексів може вплинути на продуктивність запитів, тому слід обережно підходити до цього процесу.

18. **Що таке унікальні індекси і як їх створити?**
    Унікальні індекси у MongoDB забезпечують унікальність значень у певному полі або комбінації полів. Це означає, що значення унікального індексу не можуть повторюватися. Створення унікального індексу здійснюється за допомогою параметра `{ unique: true }`. Приклад:
   ```javascript
   db.collection.createIndex({ email: 1 }, { unique: true });
   ```
У цьому прикладі індекс забезпечить, що значення поля `email` буде унікальним у колекції. Якщо спробувати вставити документ з уже існуючим значенням `email`, MongoDB видасть помилку.

19. **Як MongoDB обробляє конфлікти з індексами?**
    Конфлікти з індексами у MongoDB можуть виникати при спробі вставити або оновити документ з даними, що порушують унікальність індексу. У таких випадках MongoDB видає помилку і не дозволяє виконати операцію. Для обробки таких ситуацій можна використовувати методи з параметрами, що дозволяють ігнорувати або обробляти помилки, такі як `insertMany()` з параметром `{ ordered: false }`, що дозволяє продовжити вставку навіть при виникненні помилок.

20. **Що таке шардинг і як він реалізований у MongoDB?**
    Шардинг у MongoDB — це метод горизонтального масштабування бази даних шляхом розподілу даних між кількома серверами або кластерами. Це дозволяє розподілити навантаження і забезпечити високу продуктивність та доступність даних. Основні компоненти шардингу:
- **Шарди (Shards):** Сервери або кластери, що зберігають частини даних.
- **Мапери (Mongos):** Проксі-сервери, що маршрутизують запити до відповідних шард.
- **Конфігураційні сервери:** Зберігають метадані про розподіл даних між шард.

Шардинг реалізується наступним чином:
1. **Конфігурація кластеру:** Налаштування конфігураційних серверів та шард.
2. **Розбиття даних:** Визначення ключа шардингу, за яким дані будуть розподілятися.
3. **Маршрутизація запитів:** Використання маперів для маршрутизації запитів до відповідних шард.

21. **Як MongoDB обробляє реплікацію?**
    Реплікація у MongoDB забезпечує високу доступність і надійність даних шляхом створення копій бази даних на кількох серверах. Основний механізм реплікації — це реплікаційні набори (Replica Sets), які включають:
- **Головний вузол (Primary):** Приймає всі операції запису.
- **Вторинні вузли (Secondary):** Отримують копії даних від головного вузла і можуть обробляти запити на читання.
- **Арбітр (Arbiter):** Учасник реплікаційного набору, що бере участь у виборах, але не зберігає дані.

Реплікація відбувається наступним чином:
1. **Первинний вузол приймає операції запису і журналює їх.**
2. **Вторинні вузли отримують журнали змін від первинного вузла і застосовують їх до своїх даних.**
3. **Якщо первинний вузол виходить з ладу, вторинні вузли проводять вибори і вибирають новий первинний вузол.**

22. **Що таке реплікаційні набори у MongoDB?**
    Реплікаційні набори (Replica Sets) у MongoDB — це групи серверів, що зберігають копії однієї і тієї ж бази даних для забезпечення надійності і доступності даних. Основні компоненти реплікаційного набору включають первинний вузол (primary), вторинні вузли (secondary) та арбітри (arbiters). Реплікаційні набори дозволяють автоматично обробляти збої і забезпечують високу доступність даних.

23. **Як налаштувати реплікацію у MongoDB?**
    Налаштування реплікації у MongoDB включає наступні кроки:
1. **Ініціалізація реплікаційного набору:** Запуск mongod з параметром `--replSet`.
   ```shell
   mongod --replSet "rs0"
   ```
2. **Конфігурація реплікаційного набору:** Використання методу `rs.initiate()` для ініціалізації конфігурації.
   ```javascript
   rs.initiate({
     _id: "rs0",
     members: [
       { _id: 0, host: "host1:27017" },
       { _id: 1, host: "host2:27017" },
       { _id: 2, host: "host3:27017" }
     ]
   });
   ```
3. **Додавання вторинних вузлів:** Використання методу `rs.add()` для додавання нових членів до реплікаційного набору.
   ```javascript
   rs.add("host4:27017");
   ```

24. **Що таке арбітр у реплікаційному наборі?**
    Арбітр (Arbiter) у реплікаційному наборі MongoDB — це вузол, який бере участь у виборах первинного вузла, але не зберігає копію даних. Арбітри використовуються для підтримки непарної кількості голосів у реплікаційному наборі, що допомагає уникнути ситуацій, коли не можливо провести вибори через рівну кількість голосів. Арбітр додається до реплікаційного набору за допомогою методу `rs.addArb()`. Приклад:
   ```javascript
   rs.addArb("host5:27017");
   ```

25. **Як MongoDB обробляє конфлікти реплікації?**
    Конфлікти реплікації у MongoDB обробляються шляхом визначення пріоритетів і журналювання операцій. У разі виникнення конфліктів, наприклад, коли первинний вузол виходить з ладу і один з вторинних вузлів стає новим первинним, MongoDB використовує журнала змін для синхронізації даних між вузлами. Вторинні вузли перевіряють журнали змін і застосовують операції, які були виконані на новому первинному вузлі після виборів.

26. **Що таке "write concern" і як його використовувати?**
    "Write concern" у MongoDB визначає рівень підтвердження записів, який вимагається від сервера при виконанні операцій запису. Це дозволяє контролювати баланс між продуктивністю і надійністю даних. Основні рівні "write concern":
- **"w: 1":** Підтвердження запису від первинного вузла.
- **"w: majority":** Підтвердження запису від більшості членів реплікаційного набору.
- **"w: 0":** Без підтвердж

ення запису (негайне повернення).

Приклад використання "write concern":
   ```javascript
   db.collection.insertOne({ name: "Alice" }, { writeConcern: { w: "majority" } });
   ```

27. **Що таке "read concern" і як його налаштувати?**
    "Read concern" у MongoDB визначає рівень ізоляції для операцій читання. Це дозволяє контролювати, які дані будуть доступні для читання в залежності від їх консистентності. Основні рівні "read concern":
- **"local":** Читання з локальних даних (не гарантована консистентність).
- **"majority":** Читання з більшості членів реплікаційного набору (гарантована консистентність).
- **"linearizable":** Читання тільки після підтвердження запису (високий рівень консистентності).

Приклад використання "read concern":
   ```javascript
   db.collection.find({}).readConcern("majority");
   ```

28. **Як MongoDB обробляє транзакції?**
    Транзакції у MongoDB забезпечують підтримку ACID властивостей (атомарність, консистентність, ізоляція, надійність) для багатодокументних операцій. Транзакції дозволяють виконувати кілька операцій запису як одну атомарну операцію. Транзакції підтримуються у реплікаційних наборах і шардованих кластерах. Основні кроки для роботи з транзакціями:
1. **Початок сесії:** Використання методу `startSession()`.
   ```javascript
   const session = client.startSession();
   ```
2. **Початок транзакції:** Використання методу `startTransaction()`.
   ```javascript
   session.startTransaction();
   ```
3. **Виконання операцій:** Виконання операцій запису в рамках транзакції.
   ```javascript
   db.collection.insertOne({ name: "Alice" }, { session });
   db.collection.updateOne({ name: "Alice" }, { $set: { age: 30 } }, { session });
   ```
4. **Коміт або відкат:** Завершення транзакції за допомогою методів `commitTransaction()` або `abortTransaction()`.
   ```javascript
   session.commitTransaction();
   session.endSession();
   ```

29. **Як створити транзакцію у MongoDB?**
    Для створення транзакції у MongoDB потрібно використовувати сесії. Основні кроки для створення транзакції:
1. **Початок сесії:** Використання методу `startSession()`.
   ```javascript
   const session = client.startSession();
   ```
2. **Початок транзакції:** Використання методу `startTransaction()`.
   ```javascript
   session.startTransaction();
   ```
3. **Виконання операцій:** Виконання операцій запису в рамках транзакції.
   ```javascript
   db.collection.insertOne({ name: "Alice" }, { session });
   db.collection.updateOne({ name: "Alice" }, { $set: { age: 30 } }, { session });
   ```
4. **Коміт або відкат:** Завершення транзакції за допомогою методів `commitTransaction()` або `abortTransaction()`.
   ```javascript
   session.commitTransaction();
   session.endSession();
   ```

30. **Що таке капітальні транзакції і як вони працюють у MongoDB?**
    Капітальні транзакції у MongoDB (multi-document transactions) дозволяють виконувати кілька операцій запису як одну атомарну операцію. Це забезпечує консистентність даних у разі успішного завершення транзакції або повернення до попереднього стану у разі помилки. Капітальні транзакції підтримуються у реплікаційних наборах і шардованих кластерах, починаючи з версії 4.0. Основні кроки роботи з капітальними транзакціями:
1. **Початок сесії:** Використання методу `startSession()`.
   ```javascript
   const session = client.startSession();
   ```
2. **Початок транзакції:** Використання методу `startTransaction()`.
   ```javascript
   session.startTransaction();
   ```
3. **Виконання операцій:** Виконання кількох операцій запису в рамках транзакції.
   ```javascript
   db.collection.insertOne({ name: "Alice" }, { session });
   db.collection.updateOne({ name: "Alice" }, { $set: { age: 30 } }, { session });
   ```
4. **Коміт або відкат:** Завершення транзакції за допомогою методів `commitTransaction()` або `abortTransaction()`.
   ```javascript
   session.commitTransaction();
   session.endSession();
   ```

31. **Які обмеження мають транзакції у MongoDB?**
    Транзакції у MongoDB мають кілька обмежень, які потрібно враховувати при їх використанні:
- **Час виконання:** Транзакції мають бути короткотривалими, щоб уникнути блокувань і підвищення навантаження на систему.
- **Розмір транзакції:** Транзакції обмежені максимальним розміром документа, який становить 16 МБ.
- **Реплікація:** Транзакції потребують підтвердження запису від більшості членів реплікаційного набору, що може вплинути на продуктивність.
- **Обмеження на кількість операцій:** Кількість операцій у транзакції не повинна бути надто великою, щоб уникнути проблем з пам'яттю і продуктивністю.
- **Підтримка індексів:** Транзакції не підтримують створення або видалення індексів.

32. **Що таке агрегація у MongoDB?**
    Агрегація у MongoDB — це процес обробки і аналізу даних за допомогою різних операторів і методів. Основним інструментом для агрегації є агрегаційний фреймворк, який дозволяє виконувати складні операції над даними, такі як фільтрація, групування, сортування і перетворення. Агрегація виконується за допомогою "pipeline", який складається з послідовності етапів (stages). Кожен етап обробляє дані і передає результат наступному етапу. Приклад агрегаційного запиту:
   ```javascript
   db.orders.aggregate([
     { $match: { status: "completed" } },
     { $group: { _id: "$customerId", totalAmount: { $sum: "$amount" } } },
     { $sort: { totalAmount: -1 } },
     { $limit: 10 }
   ]);
   ```

33. **Як працює агрегаційний фреймворк у MongoDB?**
    Агрегаційний фреймворк у MongoDB дозволяє виконувати складні операції над даними за допомогою "pipeline", який складається з послідовності етапів (stages). Кожен етап обробляє вхідні дані і передає результат наступному етапу. Основні етапи агрегації включають:
- **$match:** Фільтрація документів на основі умов.
- **$group:** Групування документів і обчислення агрегатних значень.
- **$project:** Перетворення документів і вибір полів.
- **$sort:** Сортування документів.
- **$limit:** Обмеження кількості результатів.
- **$unwind:** Розгортання масивів у документи.
  Агрегаційний запит виконується методом `aggregate()`, який приймає масив етапів:
   ```javascript
   db.collection.aggregate([
     { $match: { field: value } },
     { $group: { _id: "$groupField", total: { $sum: "$amount" } } },
     { $sort: { total: -1 } }
   ]);
   ```

34. **Що таке "aggregation pipeline" і як його використовувати?**
    "Aggregation pipeline" у MongoDB — це послідовність етапів (stages), які виконуються над даними для їх обробки і аналізу. Кожен етап виконує певну операцію, таку як фільтрація, групування, сортування або перетворення. Етапи виконуються послідовно, передаючи результати з одного етапу до наступного. Приклад агрегаційного "pipeline":
   ```javascript
   db.orders.aggregate([
     { $match: {

 status: "completed" } },
     { $group: { _id: "$customerId", totalAmount: { $sum: "$amount" } } },
     { $sort: { totalAmount: -1 } },
     { $limit: 10 }
   ]);
   ```
У цьому прикладі "pipeline" складається з чотирьох етапів: фільтрація документів за статусом, групування за клієнтом, сортування за загальною сумою і обмеження кількості результатів.

35. **Які основні оператори агрегації підтримує MongoDB?**
    MongoDB підтримує широкий спектр операторів агрегації, які можна використовувати у "pipeline". Основні оператори агрегації включають:
- **$match:** Фільтрація документів на основі умов.
  ```javascript
  { $match: { status: "completed" } }
  ```
- **$group:** Групування документів і обчислення агрегатних значень.
  ```javascript
  { $group: { _id: "$customerId", totalAmount: { $sum: "$amount" } } }
  ```
- **$project:** Перетворення документів і вибір полів.
  ```javascript
  { $project: { _id: 0, customerId: 1, totalAmount: 1 } }
  ```
- **$sort:** Сортування документів.
  ```javascript
  { $sort: { totalAmount: -1 } }
  ```
- **$limit:** Обмеження кількості результатів.
  ```javascript
  { $limit: 10 }
  ```
- **$unwind:** Розгортання масивів у документи.
  ```javascript
  { $unwind: "$items" }
  ```
- **$lookup:** Виконання об'єднання (join) з іншою колекцією.
  ```javascript
  {
    $lookup: {
      from: "customers",
      localField: "customerId",
      foreignField: "_id",
      as: "customerDetails"
    }
  }
  ```

36. **Як працює оператор $match у агрегації?**
    Оператор `$match` у агрегації MongoDB використовується для фільтрації документів на основі умов, подібно до оператора `find()`. `$match` обмежує документи, які проходять через "pipeline", залишаючи лише ті, що задовольняють задані умови. Приклад використання `$match`:
   ```javascript
   db.orders.aggregate([
     { $match: { status: "completed", amount: { $gt: 100 } } }
   ]);
   ```
У цьому прикладі `$match` фільтрує документи, де статус дорівнює "completed" і сума більше 100.

37. **Що таке оператор $group у агрегації?**
    Оператор `$group` у агрегації MongoDB використовується для групування документів за певними полями і обчислення агрегатних значень, таких як сума, середнє значення, кількість тощо. Основний синтаксис `$group`:
   ```javascript
   { $group: { _id: <group_by_field>, <agg_field>: { <agg_operator>: <expression> } } }
   ```
Приклад використання `$group`:
   ```javascript
   db.orders.aggregate([
     { $group: { _id: "$customerId", totalAmount: { $sum: "$amount" }, averageAmount: { $avg: "$amount" } } }
   ]);
   ```
У цьому прикладі документи групуються за `customerId`, обчислюється загальна сума і середнє значення суми для кожного клієнта.

38. **Як працює оператор $project у агрегації?**
    Оператор `$project` у агрегації MongoDB використовується для перетворення документів і вибору полів, які будуть включені у результати. `$project` дозволяє обчислювати нові поля, виключати або перейменовувати існуючі поля. Основний синтаксис `$project`:
   ```javascript
   { $project: { <field1>: <expression1>, <field2>: <expression2>, ... } }
   ```
Приклад використання `$project`:
   ```javascript
   db.orders.aggregate([
     { $project: { _id: 0, customerId: 1, totalAmount: "$amount", orderDate: 1 } }
   ]);
   ```
У цьому прикладі вибираються поля `customerId`, `amount` (перейменоване на `totalAmount`) і `orderDate`, при цьому поле `_id` виключається з результатів.

39. **Що таке оператор $unwind і як його використовувати?**
    Оператор `$unwind` у агрегації MongoDB використовується для розгортання масивів у документи. Кожен елемент масиву перетворюється на окремий документ. Це корисно для обробки даних, що містять масиви. Основний синтаксис `$unwind`:
   ```javascript
   { $unwind: "$arrayField" }
   ```
Приклад використання `$unwind`:
   ```javascript
   db.orders.aggregate([
     { $unwind: "$items" },
     { $group: { _id: "$customerId", totalItems: { $sum: 1 }, totalAmount: { $sum: "$items.price" } } }
   ]);
   ```
У цьому прикладі масив `items` розгортається, після чого документи групуються за `customerId`, обчислюється загальна кількість товарів і сума цін.

40. **Як MongoDB обробляє великі колекції?**
    MongoDB обробляє великі колекції за допомогою кількох механізмів, що забезпечують ефективність і продуктивність:
- **Індекси:** Використання індексів для прискорення запитів і зменшення часу сканування колекцій.
- **Шардинг:** Горизонтальне масштабування даних за допомогою розподілу їх між кількома шард.
- **Агрегаційний фреймворк:** Виконання складних запитів і обробки даних за допомогою агрегаційного "pipeline".
- **Капітальні колекції:** Використання капітальних колекцій для зберігання обмеженого обсягу даних, що автоматично видаляються після досягнення певного розміру.
- **TTL індекси:** Використання індексів з обмеженим терміном життя для автоматичного видалення старих документів.
- **Профілювання запитів:** Використання профайлера запитів для моніторингу і оптимізації виконання запитів.

41. **Що таке розділи (partitions) у MongoDB?**
    Розділи (partitions) у MongoDB зазвичай відносяться до механізму шардингу, де колекція розділяється на частини, які зберігаються на різних шардах. Це дозволяє горизонтально масштабувати базу даних, розподіляючи навантаження між кількома серверами. Кожен шард містить підмножину даних колекції. Розділи визначаються на основі ключа шардингу, який обирається відповідно до конкретних вимог до доступності і продуктивності. Приклад налаштування шардингу:
   ```javascript
   // Включення шардингу для бази даних
   sh.enableSharding("myDatabase");
   
   // Вибір ключа шардингу для колекції
   sh.shardCollection("myDatabase.myCollection", { shardKey: 1 });
   ```

42. **Як створити і використовувати капітальні колекції у MongoDB?**
    Капітальні колекції (capped collections) у MongoDB — це спеціальні види колекцій з фіксованим розміром, які автоматично видаляють старі документи, коли досягається максимальний розмір. Капітальні колекції зберігають документи у порядку їх вставки і не дозволяють оновлення, що збільшують розмір документа. Створення капітальної колекції:
   ```javascript
   db.createCollection("myCappedCollection", { capped: true, size: 5242880, max: 5000 });
   ```
У цьому прикладі створюється капітальна колекція з максимальним розміром 5 МБ і обмеженням у 5000 документів.

43. **Що таке capped collections і як їх використовувати?**
    Капітальні колекції (capped collections) у MongoDB — це спеціальні види колекцій, які мають фіксований розмір і автоматично видаляють старі документи, коли досягається максимальний розмір. Вони забезпечують високу продуктивність для операцій вставки і читання, але не дозволяють операції видалення або оновлення, які збільшують розмір документа. Капітальні колекції зазвичай використовуються для зберігання журналів або лімітованих наборів даних. Приклад створення капітальної колекції:
   ```javascript
   db.createCollection("myCappedCollection", { capped: true, size: 5242880, max: 5000 });
   ```
Для вставки документів у капітальну колекцію використовується звичайний метод `insert`:
   ```javascript
   db.myCappedCollection.insert({ message: "Hello, world!", timestamp: new Date() });
   ```

44. **Як MongoDB обробляє TTL індекси?**
    TTL індекси (Time To Live) у MongoDB використовуються для автоматичного видалення документів після закінчення певного часу. Це корисно для керування життєвим циклом даних, наприклад, для видалення застарілих записів або журналів. TTL індекси створюються з параметром `expireAfterSeconds`, який визначає час життя документа в секундах. Приклад створення TTL індексу:
   ```javascript
   db.session.createIndex({ createdAt: 1 }, { expireAfterSeconds: 3600 });
   ```
У цьому прикладі документи у колекції `session` будуть автоматично видалені через 1 годину після створення.

45. **Що таке GridFS і як його використовувати?**
    GridFS — це спеціальна специфікація у MongoDB для зберігання і обробки великих файлів, таких як зображення, відео або аудіо, розміром понад 16 МБ (максимальний розмір документа у MongoDB). GridFS розбиває файли на невеликі частини (зазвичай 255 КБ) і зберігає їх у двох колекціях: `fs.files` і `fs.chunks`. Приклад завантаження файлу у GridFS за допомогою драйвера MongoDB:
   ```javascript
   const fs = require('fs');
   const MongoClient = require('mongodb').MongoClient;
   const GridFSBucket = require('mongodb').GridFSBucket;

   MongoClient.connect('mongodb://localhost:27017', { useNewUrlParser: true, useUnifiedTopology: true }, function(err, client) {
     const db = client.db('myDatabase');
     const bucket = new GridFSBucket(db);

     fs.createReadStream('path/to/file').pipe(bucket.openUploadStream('myFile', {
       chunkSizeBytes: 255 * 1024,
       metadata: { field: 'value' }
     })).on('error', function(error) {
       console.log('Error:', error);
     }).on('finish', function() {
       console.log('File uploaded successfully.');
     });
   });
   ```

46. **Як працює файлова система GridFS у MongoDB?**
    GridFS — це файлова система для зберігання великих файлів у MongoDB. Вона розбиває файли на невеликі частини (частки) і зберігає їх у колекціях `fs.files` і `fs.chunks`. Колекція `fs.files` містить метадані файлів, такі як ім'я, розмір і дата завантаження, тоді як колекція `fs.chunks` містить фактичні дані файлів, розбиті на частки. Приклад структури документів у GridFS:
- **fs.files:**
  ```json
  {
    "_id": ObjectId("5f1a4e2d8b799e8b34172f9b"),
    "filename": "myFile",
    "length": 10485760,
    "chunkSize": 255 * 1024,
    "uploadDate": ISODate("2020-07-24T12:34:56.789Z"),
    "metadata": { "field": "value" }
  }
  ```
- **fs.chunks:**
  ```json
  {
    "_id": ObjectId("5f1a4e2d8b799e8b34172f9c"),
    "files_id": ObjectId("5f1a4e2d8b799e8b34172f9b"),
    "n": 0,
    "data": BinData(0, "...")
  }
  ```

47. **Що таке "change streams" і як їх використовувати?**
    "Change streams" у MongoDB дозволяють відстежувати зміни у колекціях і базах даних у режимі реального часу. Вони використовуються для обробки подій, що виникають при вставці, оновленні або видаленні документів. Приклад створення "change stream":
   ```javascript
   const MongoClient = require('mongodb').MongoClient;

   MongoClient.connect('mongodb://localhost:27017', { useNewUrlParser: true, useUnifiedTopology: true }, function(err, client) {
     const db = client.db('myDatabase');
     const changeStream = db.collection('myCollection').watch();

     changeStream.on('change', function(change) {
       console.log('Change detected:', change);
     });
   });
   ```
"Change streams" можна використовувати для різних задач, таких як синхронізація даних між базами даних, обробка подій у реальному часі або побудова реактивних додатків.

48. **Як налаштувати і використовувати "change streams" у MongoDB?**
    Для налаштування і використання "change streams" у MongoDB необхідно підключитися до бази даних, створити "change stream" для колекції або бази даних і обробляти події, що виникають при зміні даних. Приклад налаштування "change stream" для колекції:
   ```javascript
   const MongoClient = require('mongodb').MongoClient;

   MongoClient.connect('mongodb://localhost:27017', { useNewUrlParser: true, useUnifiedTopology: true }, function(err, client) {
     const db = client.db('myDatabase');
     const changeStream = db.collection('myCollection').watch();

     changeStream.on('change', function(change) {
       console.log('Change detected:', change);
     });
   });
   ```
"Change streams" підтримують фільтрацію подій за допомогою агрегаційного "pipeline". Приклад фільтрації подій за типом операції:
   ```javascript
   const changeStream = db.collection('myCollection').watch([
     { $match: { operationType: 'insert' } }
   ]);
   changeStream.on('change', function(change) {
     console.log('Insert detected:', change);
   });
   ```

49.

**Що таке MongoDB Atlas і які його переваги?**
MongoDB Atlas — це керований хмарний сервіс для MongoDB, який забезпечує автоматизоване розгортання, масштабування та управління кластерами MongoDB у різних хмарних провайдерах, таких як AWS, Azure та Google Cloud. Основні переваги MongoDB Atlas:
- **Автоматизація:** Автоматичне створення, налаштування та оновлення кластерів.
- **Масштабованість:** Горизонтальне масштабування кластерів без простоїв.
- **Висока доступність:** Вбудована підтримка реплікації та відновлення після збоїв.
- **Безпека:** Вбудовані засоби безпеки, такі як шифрування даних, контроль доступу та моніторинг.
- **Моніторинг і аналіз:** Інструменти для моніторингу продуктивності, аналізу запитів та оптимізації.
- **Інтеграції:** Підтримка інтеграцій з іншими сервісами та інструментами, такими як AWS Lambda, Google BigQuery тощо.

MongoDB Atlas дозволяє розробникам зосередитися на розробці додатків, не турбуючись про управління інфраструктурою бази даних.

50. **Як налаштувати MongoDB Atlas для проекту?**
    Для налаштування MongoDB Atlas для проекту необхідно виконати наступні кроки:
1. **Створення облікового запису:** Зареєструйтеся на сайті MongoDB Atlas.
2. **Створення кластера:** Увійдіть у свій обліковий запис і створіть новий кластер, вибравши хмарного провайдера, регіон та конфігурацію кластера.
3. **Налаштування доступу:** Додайте IP-адреси, з яких дозволений доступ до кластера, та створіть користувача з відповідними правами доступу.
4. **Підключення до кластера:** Використовуйте наданий URI для підключення до кластера за допомогою драйвера MongoDB або іншого інструменту.
   Приклад підключення до MongoDB Atlas за допомогою Node.js:
   ```javascript
   const MongoClient = require('mongodb').MongoClient;
   const uri = "your-atlas-cluster-uri";
   
   MongoClient.connect(uri, { useNewUrlParser: true, useUnifiedTopology: true }, function(err, client) {
     if (err) throw err;
     const db = client.db('myDatabase');
     // Виконання операцій з базою даних
   });
   ```
MongoDB Atlas забезпечує просте і швидке розгортання кластерів, надаючи інструменти для моніторингу, масштабування та управління базою даних.

51. **Що таке "performance tuning" у MongoDB і як його виконувати?**
    "Performance tuning" у MongoDB — це процес оптимізації бази даних для покращення продуктивності і зниження часу виконання запитів. Основні підходи до оптимізації продуктивності включають:
- **Використання індексів:** Створення індексів для полів, які часто використовуються у запитах для підвищення швидкості пошуку.
- **Оптимізація запитів:** Аналіз і оптимізація запитів за допомогою методів `explain()` і профайлерів запитів.
- **Підтримка актуальності даних:** Використання TTL індексів і капітальних колекцій для автоматичного видалення застарілих даних.
- **Моніторинг продуктивності:** Використання інструментів моніторингу, таких як MongoDB Atlas, для відстеження продуктивності і виявлення вузьких місць.
- **Розподіл навантаження:** Використання реплікації і шардингу для розподілу навантаження між кількома серверами і підвищення доступності даних.
- **Оптимізація схем:** Проектування схем з урахуванням особливостей MongoDB, таких як використання вбудованих документів і масивів для зниження кількості операцій з'єднання.

52. **Як використовувати профайлер запитів у MongoDB?**
    Профайлер запитів у MongoDB — це інструмент, який дозволяє відстежувати і аналізувати виконання запитів у базі даних. Профайлер збирає інформацію про всі виконані запити, включаючи їх час виконання, використання індексів і кількість оброблених документів. Налаштування профайлера:
   ```javascript
   // Включення профайлера для всіх запитів
   db.setProfilingLevel(2);
   
   // Включення профайлера для повільних запитів
   db.setProfilingLevel(1, { slowms: 100 });
   ```
Аналіз результатів профайлера:
   ```javascript
   db.system.profile.find().sort({ ts: -1 }).limit(5).pretty();
   ```
Профайлер запитів допомагає виявити повільні і неефективні запити, оптимізувати їх і покращити продуктивність бази даних.

53. **Що таке "schema design" у MongoDB і як його оптимізувати?**
    "Schema design" у MongoDB — це процес проектування структури даних для забезпечення ефективного зберігання, доступу і обробки даних. Оптимізація схеми включає:
- **Використання вбудованих документів:** Зберігання пов'язаних даних у одному документі для зниження кількості операцій з'єднання.
- **Використання масивів:** Зберігання повторюваних даних у масивах для підвищення продуктивності і зручності доступу.
- **Уникання вкладених масивів:** Уникання глибоких вкладень масивів для спрощення обробки даних.
- **Оптимізація індексів:** Створення індексів для полів, які часто використовуються у запитах, для підвищення швидкості пошуку.
- **Підтримка гнучкості:** Використання безсхемної структури даних для забезпечення гнучкості у змінах структури даних.

Приклад проектування схеми для блогу:
   ```javascript
   {
     "_id": ObjectId("5f1a4e2d8b799e8b34172f9b"),
     "title": "My Blog Post",
     "author": "John Doe",
     "content": "This is the content of the blog post.",
     "comments": [
       {
         "user": "Alice",
         "comment": "Great post!",
         "timestamp": ISODate("2020-07-24T12:34:56.789Z")
       },
       {
         "user": "Bob",
         "comment": "Thanks for sharing.",
         "timestamp": ISODate("2020-07-24T13:45:12.345Z")
       }
     ]
   }
   ```

54. **Які кращі практики проектування схеми для MongoDB?**
    Кращі практики проектування схеми для MongoDB включають:
- **Використання вбудованих документів:** Зберігання пов'язаних даних у одному документі для зниження кількості операцій з'єднання.
- **Використання масивів:** Зберігання повторюваних даних у масивах для підвищення продуктивності і зручності доступу.
- **Оптимізація індексів:** Створення індексів для полів, які часто використовуються у запитах, для підвищення швидкості пошуку.
- **Уникання вкладених масивів:** Уникання глибоких вкладень масивів для спрощення обробки даних.
- **Підтримка гнучкості:** Використання безсхемної структури даних для забезпечення гнучкості у змінах структури даних.
- **Планування зберігання:** Розробка схеми з урахуванням майбутнього росту даних і вимог до зберігання.
- **Моніторинг продуктивності:** Регулярний аналіз продуктивності запитів і оптимізація схеми на основі результатів профайлера запитів.
- **Використання капітальних колекцій:** Використання капітальних колекцій



для зберігання даних з обмеженим життєвим циклом.

55. **Що таке Mongoose і як його використовувати з MongoDB?**
    Mongoose — це об'єктно-документний мапер (ODM) для Node.js, який спрощує роботу з MongoDB, надаючи інтерфейс для визначення схем, моделей і взаємодії з базою даних. Mongoose дозволяє визначати структуру документів, валідацію, перетворення типів та інші функції. Приклад використання Mongoose:
   ```javascript
   const mongoose = require('mongoose');
   
   // Підключення до MongoDB
   mongoose.connect('mongodb://localhost:27017/myDatabase', { useNewUrlParser: true, useUnifiedTopology: true });
   
   // Визначення схеми
   const userSchema = new mongoose.Schema({
     name: String,
     email: { type: String, required: true, unique: true },
     age: Number
   });
   
   // Створення моделі
   const User = mongoose.model('User', userSchema);
   
   // Створення нового користувача
   const newUser = new User({ name: 'Alice', email: 'alice@example.com', age: 25 });
   newUser.save(function(err) {
     if (err) return console.error(err);
     console.log('User saved successfully.');
   });
   ```

56. **Як налаштувати і використовувати Mongoose у проекті?**
    Для налаштування і використання Mongoose у проекті необхідно виконати наступні кроки:
1. **Встановлення Mongoose:** Використовуйте npm для встановлення Mongoose.
   ```shell
   npm install mongoose
   ```
2. **Підключення до MongoDB:** Підключіться до бази даних MongoDB за допомогою Mongoose.
   ```javascript
   const mongoose = require('mongoose');
   mongoose.connect('mongodb://localhost:27017/myDatabase', { useNewUrlParser: true, useUnifiedTopology: true });
   ```
3. **Визначення схеми:** Визначте схему для моделі.
   ```javascript
   const userSchema = new mongoose.Schema({
     name: String,
     email: { type: String, required: true, unique: true },
     age: Number
   });
   ```
4. **Створення моделі:** Створіть модель на основі схеми.
   ```javascript
   const User = mongoose.model('User', userSchema);
   ```
5. **Виконання CRUD операцій:** Використовуйте модель для виконання операцій створення, читання, оновлення і видалення.
   ```javascript
   // Створення нового користувача
   const newUser = new User({ name: 'Alice', email: 'alice@example.com', age: 25 });
   newUser.save(function(err) {
     if (err) return console.error(err);
     console.log('User saved successfully.');
   });
   ```

57. **Що таке "data validation" у MongoDB і як його налаштувати?**
    "Data validation" у MongoDB — це процес перевірки даних перед їх вставкою або оновленням у базі даних для забезпечення їх відповідності заданим правилам. MongoDB підтримує валідацію схеми на рівні колекції за допомогою JSON Schema. Валідація схеми дозволяє визначати типи даних, обов'язкові поля, діапазони значень та інші правила. Приклад налаштування валідації схеми:
   ```javascript
   db.createCollection("users", {
     validator: {
       $jsonSchema: {
         bsonType: "object",
         required: ["name", "email"],
         properties: {
           name: {
             bsonType: "string",
             description: "must be a string and is required"
           },
           email: {
             bsonType: "string",
             pattern: "^.+@.+\..+$",
             description: "must be a valid email address and is required"
           },
           age: {
             bsonType: "int",
             minimum: 0,
             description: "must be a non-negative integer"
           }
         }
       }
     }
   });
   ```
Цей приклад створює колекцію `users` з валідацією, що перевіряє, чи поля `name` і `email` є рядками і обов'язковими, а поле `email` має формат електронної пошти.

58. **Як працює "schema validation" у MongoDB?**
    "Schema validation" у MongoDB дозволяє перевіряти структуру документів при їх вставці або оновленні відповідно до заданих правил. Валідація схеми використовує JSON Schema для визначення типів даних, обов'язкових полів, діапазонів значень та інших правил. Основні етапи налаштування валідації схеми:
1. **Створення колекції з валідацією:** Використання методу `createCollection()` з параметром `validator`.
   ```javascript
   db.createCollection("users", {
     validator: {
       $jsonSchema: {
         bsonType: "object",
         required: ["name", "email"],
         properties: {
           name: {
             bsonType: "string",
             description: "must be a string and is required"
           },
           email: {
             bsonType: "string",
             pattern: "^.+@.+\..+$",
             description: "must be a valid email address and is required"
           },
           age: {
             bsonType: "int",
             minimum: 0,
             description: "must be a non-negative integer"
           }
         }
       }
     }
   });
   ```
2. **Оновлення валідації схеми:** Використання методу `collMod` для оновлення правил валідації схеми.
   ```javascript
   db.runCommand({
     collMod: "users",
     validator: {
       $jsonSchema: {
         bsonType: "object",
         required: ["name", "email"],
         properties: {
           name: {
             bsonType: "string",
             description: "must be a string and is required"
           },
           email: {
             bsonType: "string",
             pattern: "^.+@.+\..+$",
             description: "must be a valid email address and is required"
           },
           age: {
             bsonType: "int",
             minimum: 0,
             description: "must be a non-negative integer"
           }
         }
       }
     }
   });
   ```
Валідація схеми забезпечує консистентність і якість даних у колекціях MongoDB, запобігаючи вставці або оновленню некоректних даних.

59. **Як налаштувати "schema validation" для колекцій?**
    Для налаштування "schema validation" для колекцій у MongoDB необхідно використовувати параметр `validator` при створенні або модифікації колекції. Приклад налаштування валідації схеми для нової колекції:
   ```javascript
   db.createCollection("users", {
     validator: {
       $jsonSchema: {
         bsonType: "object",
         required: ["name", "email"],
         properties: {
           name: {
             bsonType: "string",
             description: "must be a string and is required"
           },
           email: {
             bsonType: "string",
             pattern: "^.+@.+\..+$",
             description: "must be a valid email address and is required"
           },
           age: {
             bsonType: "int",
             minimum: 0,
             description: "must be a non-negative integer"
           }
         }
       }
     }
   });
   ```
Для оновлення валідації схеми існуючої колекції використовується команда `collMod`:
   ```javascript
   db.runCommand({
     collMod: "users",
     validator: {
       $jsonSchema: {
         bsonType: "object",
         required: ["name", "email"],
         properties: {
           name: {
             bsonType: "string",
             description: "must be a string and is required"
           },
           email: {
             bsonType: "string",
             pattern: "^.+@.+\..+$",
             description: "must be a valid email address and is required"
           },
           age: {
             bsonType: "int",
             minimum: 0,
             description: "must be a non-negative integer"
           }
         }
       }
     }
   });
   ```

60. **Що таке "embedded documents" і як їх використовувати?**
    Вбудовані документи (embedded documents) у MongoDB дозволяють зберігати пов'язані дані в одному документі, що забезпечує ефективність і простоту доступу до даних. Вони використовуються для зберігання даних, які мають тісний зв'язок і зазвичай обробляються разом. Приклад використання вбудованих документів:
   ```javascript
   {
     "_id": ObjectId("5f1a4e2d



8b799e8b34172f9b"),
     "name": "John Doe",
     "email": "john.doe@example.com",
     "address": {
       "street": "123 Main St",
       "city": "New York",
       "state": "NY",
       "zip": "10001"
     }
   }
   ```
61. **Як працюють "referenced documents" у MongoDB?**
    Документи з посиланнями (referenced documents) у MongoDB використовуються для зберігання зв'язків між документами у різних колекціях. Замість зберігання всіх пов'язаних даних у одному документі, використовується посилання (Reference) на інші документи. Це дозволяє зберігати дані більш розподілено та уникати дублювання. Наприклад, зберігання користувачів та їхніх замовлень:
- **Колекція користувачів (users):**
  ```json
  {
    "_id": ObjectId("5f1a4e2d8b799e8b34172f9b"),
    "name": "John Doe",
    "email": "john.doe@example.com"
  }
  ```
- **Колекція замовлень (orders):**
  ```json
  {
    "_id": ObjectId("5f1a4e2d8b799e8b34172f9c"),
    "userId": ObjectId("5f1a4e2d8b799e8b34172f9b"),
    "product": "Laptop",
    "quantity": 1,
    "price": 1000
  }
  ```
У цьому прикладі замовлення містить поле `userId`, яке посилається на користувача у колекції `users`. Для отримання повної інформації про замовлення разом із користувачем використовується оператор `$lookup`:
   ```javascript
   db.orders.aggregate([
     {
       $lookup: {
         from: "users",
         localField: "userId",
         foreignField: "_id",
         as: "userDetails"
       }
     }
   ]);
   ```

62. **Як реалізувати відносини між документами у MongoDB?**
    Відносини між документами у MongoDB реалізуються за допомогою вбудованих документів (embedded documents) або посилань (referenced documents). Вибір методу залежить від характеру даних і вимог до продуктивності. Приклад реалізації відносин між користувачами і їх замовленнями:
- **Вбудовані документи (Embedded documents):** Зберігання замовлень у документі користувача.
  ```json
  {
    "_id": ObjectId("5f1a4e2d8b799e8b34172f9b"),
    "name": "John Doe",
    "email": "john.doe@example.com",
    "orders": [
      {
        "product": "Laptop",
        "quantity": 1,
        "price": 1000
      },
      {
        "product": "Phone",
        "quantity": 2,
        "price": 500
      }
    ]
  }
  ```
- **Посилання (Referenced documents):** Зберігання посилань на замовлення у окремій колекції.
    - **Колекція користувачів:**
      ```json
      {
        "_id": ObjectId("5f1a4e2d8b799e8b34172f9b"),
        "name": "John Doe",
        "email": "john.doe@example.com"
      }
      ```
    - **Колекція замовлень:**
      ```json
      {
        "_id": ObjectId("5f1a4e2d8b799e8b34172f9c"),
        "userId": ObjectId("5f1a4e2d8b799e8b34172f9b"),
        "product": "Laptop",
        "quantity": 1,
        "price": 1000
      }
      ```

63. **Що таке "lookup" і як його використовувати у агрегаціях?**
    Оператор `$lookup` у MongoDB використовується для об'єднання (join) даних з різних колекцій у процесі агрегації. Це дозволяє виконувати запити, що об'єднують документи на основі певного критерію. Приклад використання `$lookup` для об'єднання колекцій `orders` і `users`:
   ```javascript
   db.orders.aggregate([
     {
       $lookup: {
         from: "users",
         localField: "userId",
         foreignField: "_id",
         as: "userDetails"
       }
     }
   ]);
   ```
У цьому прикладі всі документи з колекції `orders` будуть об'єднані з відповідними документами з колекції `users` на основі поля `userId`.

64. **Як обробляти дані з різних колекцій у MongoDB?**
    Обробка даних з різних колекцій у MongoDB може виконуватися за допомогою операторів агрегації, таких як `$lookup`, `$graphLookup`, або за допомогою коду на стороні клієнта. Оператор `$lookup` використовується для простих об'єднань між двома колекціями. Оператор `$graphLookup` використовується для рекурсивних об'єднань і обробки графів. Приклад використання `$lookup` для об'єднання даних:
   ```javascript
   db.orders.aggregate([
     {
       $lookup: {
         from: "users",
         localField: "userId",
         foreignField: "_id",
         as: "userDetails"
       }
     }
   ]);
   ```
Приклад використання `$graphLookup` для рекурсивного об'єднання даних:
   ```javascript
   db.employees.aggregate([
     {
       $graphLookup: {
         from: "employees",
         startWith: "$reportsTo",
         connectFromField: "reportsTo",
         connectToField: "_id",
         as: "hierarchy"
       }
     }
   ]);
   ```

65. **Що таке "transactions" і як їх використовувати у MongoDB?**
    Транзакції у MongoDB дозволяють виконувати кілька операцій запису як одну атомарну операцію з підтримкою ACID властивостей (атомарність, консистентність, ізоляція, надійність). Транзакції підтримуються у реплікаційних наборах і шардованих кластерах, починаючи з версії 4.0. Основні кроки для використання транзакцій:
1. **Початок сесії:** Використання методу `startSession()`.
   ```javascript
   const session = client.startSession();
   ```
2. **Початок транзакції:** Використання методу `startTransaction()`.
   ```javascript
   session.startTransaction();
   ```
3. **Виконання операцій:** Виконання операцій запису в рамках транзакції.
   ```javascript
   db.collection.insertOne({ name: "Alice" }, { session });
   db.collection.updateOne({ name: "Alice" }, { $set: { age: 30 } }, { session });
   ```
4. **Коміт або відкат:** Завершення транзакції за допомогою методів `commitTransaction()` або `abortTransaction()`.
   ```javascript
   session.commitTransaction();
   session.endSession();
   ```

66. **Як працюють "multi-document transactions" у MongoDB?**
    Транзакції для кількох документів (multi-document transactions) у MongoDB дозволяють виконувати кілька операцій запису на кількох документах як одну атомарну операцію. Це забезпечує підтримку ACID властивостей. Основні кроки роботи з транзакціями для кількох документів:
1. **Початок сесії:** Використання методу `startSession()`.
   ```javascript
   const session = client.startSession();
   ```
2. **Початок транзакції:** Використання методу `startTransaction()`.
   ```javascript
   session.startTransaction();
   ```
3. **Виконання операцій:** Виконання кількох операцій запису в рамках транзакції.
   ```javascript
   db.collection.insertOne({ name: "Alice" }, { session });
   db.collection.updateOne({ name: "Alice" }, { $set: { age: 30 } }, { session });
   ```
4. **Коміт або відкат:** Завершення транзакції за допомогою методів `commitTransaction()` або `abortTransaction()`.
   ```javascript
   session.commitTransaction();
   session.endSession();
   ```

67. **Які обмеження мають транзакції у MongoDB?**
    Транзакції у MongoDB мають кілька обмежень, які потрібно враховувати при їх використанні:
- **Час виконання:** Транзакції мають бути короткотривалими, щоб уникнути блокувань і підвищення навантаження на систему.
- **Розмір транзакції:** Транзакції обмежені максимальним розміром документа, який становить 16 М

Б.
- **Реплікація:** Транзакції потребують підтвердження запису від більшості членів реплікаційного набору, що може вплинути на продуктивність.
- **Обмеження на кількість операцій:** Кількість операцій у транзакції не повинна бути надто великою, щоб уникнути проблем з пам'яттю і продуктивністю.
- **Підтримка індексів:** Транзакції не підтримують створення або видалення індексів.
- **Підтримка шардованих кластерів:** Транзакції на шардованих кластерах можуть мати додаткові накладні витрати через координацію між шард.

68. **Що таке "replica set" і як його налаштувати?**
    Реплікаційний набір (replica set) у MongoDB — це група серверів, які зберігають копії однієї і тієї ж бази даних для забезпечення надійності і доступності даних. Основні компоненти реплікаційного набору включають первинний вузол (primary), вторинні вузли (secondary) та арбітри (arbiters). Налаштування реплікаційного набору:
1. **Ініціалізація реплікаційного набору:** Запуск mongod з параметром `--replSet`.
   ```shell
   mongod --replSet "rs0"
   ```
2. **Конфігурація реплікаційного набору:** Використання методу `rs.initiate()` для ініціалізації конфігурації.
   ```javascript
   rs.initiate({
     _id: "rs0",
     members: [
       { _id: 0, host: "host1:27017" },
       { _id: 1, host: "host2:27017" },
       { _id: 2, host: "host3:27017" }
     ]
   });
   ```
3. **Додавання вторинних вузлів:** Використання методу `rs.add()` для додавання нових членів до реплікаційного набору.
   ```javascript
   rs.add("host4:27017");
   ```

69. **Як MongoDB обробляє "failover" у реплікаційних наборах?**
    "Failover" у реплікаційних наборах MongoDB — це процес автоматичного переключення на новий первинний вузол у разі виходу з ладу поточного первинного вузла. Вторинні вузли проводять вибори для визначення нового первинного вузла на основі пріоритетів і статусу вузлів. Процес "failover" включає:
- **Виявлення збоїв:** Вторинні вузли регулярно перевіряють статус первинного вузла. Якщо первинний вузол не відповідає протягом певного часу, вторинні вузли починають вибори.
- **Вибори нового первинного вузла:** Вторинні вузли голосують за новий первинний вузол на основі пріоритетів і поточного стану даних.
- **Перемикання ролей:** Обраний вузол стає новим первинним, а інші вузли продовжують реплікацію від нового первинного вузла.
  Процес "failover" забезпечує високу доступність даних і мінімальні простої у разі збоїв.

70. **Що таке "read preferences" і як їх використовувати?**
    "Read preferences" у MongoDB дозволяють контролювати, з яких вузлів реплікаційного набору читати дані. Це корисно для розподілу навантаження між вузлами і забезпечення гнучкості доступу до даних. Основні режими "read preferences":
- **primary:** Читання тільки з первинного вузла (за замовчуванням).
- **primaryPreferred:** Читання з первинного вузла, якщо він доступний; в іншому випадку — з вторинних.
- **secondary:** Читання тільки з вторинних вузлів.
- **secondaryPreferred:** Читання з вторинних вузлів, якщо вони доступні; в іншому випадку — з первинного.
- **nearest:** Читання з найближчого вузла на основі затримки відповіді.

Приклад використання "read preferences":
   ```javascript
   const MongoClient = require('mongodb').MongoClient;
   MongoClient.connect('mongodb://localhost:27017', { useNewUrlParser: true, useUnifiedTopology: true, readPreference: 'secondaryPreferred' }, function(err, client) {
     const db = client.db('myDatabase');
     // Виконання операцій з базою даних
   });
   ```

71. **Як працюють "read preferences" у MongoDB?**
    "Read preferences" у MongoDB дозволяють контролювати, з яких вузлів реплікаційного набору читати дані. Це корисно для розподілу навантаження між вузлами і забезпечення гнучкості доступу до даних. Основні режими "read preferences":
- **primary:** Читання тільки з первинного вузла (за замовчуванням).
- **primaryPreferred:** Читання з первинного вузла, якщо він доступний; в іншому випадку — з вторинних.
- **secondary:** Читання тільки з вторинних вузлів.
- **secondaryPreferred:** Читання з вторинних вузлів, якщо вони доступні; в іншому випадку — з первинного.
- **nearest:** Читання з найближчого вузла на основі затримки відповіді.

При використанні "read preferences" клієнт MongoDB вибирає відповідний вузол для читання на основі заданого режиму і поточного стану реплікаційного набору. Це дозволяє оптимізувати продуктивність і забезпечити високий рівень доступності даних.

72. **Що таке "write concern" і як його налаштувати?**
    "Write concern" у MongoDB визначає рівень підтвердження записів, який вимагається від сервера при виконанні операцій запису. Це дозволяє контролювати баланс між продуктивністю і надійністю даних. Основні рівні "write concern":
- **"w: 1":** Підтвердження запису від первинного вузла.
- **"w: majority":** Підтвердження запису від більшості членів реплікаційного набору.
- **"w: 0":** Без підтвердження запису (негайне повернення).
- **"journal: true":** Підтвердження запису після журналювання.

Приклад використання "write concern":
   ```javascript
   db.collection.insertOne({ name: "Alice" }, { writeConcern: { w: "majority" } });
   ```

73. **Як обробляти помилки запису у MongoDB?**
    Обробка помилок запису у MongoDB включає виявлення і реагування на помилки, що виникають під час операцій запису. Основні підходи до обробки помилок:
- **Перевірка результатів операцій:** Перевірка результатів операцій запису і обробка помилок за допомогою зворотних викликів (callback) або обіцянок (promises).
  ```javascript
  db.collection.insertOne({ name: "Alice" }, function(err, res) {
    if (err) {
      console.error("Error:", err);
    } else {
      console.log("Document inserted:", res.insertedId);
    }
  });
  ```
- **Використання транзакцій:** Використання транзакцій для забезпечення атомарності операцій і відкату у разі помилок.
  ```javascript
  const session = client.startSession();
  session.startTransaction();
  try {
    db.collection.insertOne({ name: "Alice" }, { session });
    session.commitTransaction();
  } catch (err) {
    session.abortTransaction();
    console.error("Transaction aborted due to error:", err);
  } finally {
    session.endSession();
  }
  ```

74. **Що таке "write conflicts" і як їх уникнути?**
    Конфлікти запису (write conflicts) у MongoDB виникають, коли кілька операцій намагаються одночасно змінити одні й ті ж дані. Це може призвести до помилок або втрати даних. Основні методи уникнення конфліктів запису:
- **Використання транзакцій:** Забезпечення атомарності операцій і уникнення конфліктів за допомогою транзакцій.
  ```javascript
  const session = client.startSession();
  session.startTransaction();


try {
db.collection.updateOne({ _id: id }, { $set: { field: value } }, { session });
session.commitTransaction();
} catch (err) {
session.abortTransaction();
console.error("Transaction aborted due to error:", err);
} finally {
session.endSession();
}
```
- **Оптимістичне блокування:** Використання полів версій (versioning) для перевірки, чи не були дані змінені іншим процесом.
  ```javascript
  const doc = db.collection.findOne({ _id: id });
  if (doc.version === expectedVersion) {
    db.collection.updateOne({ _id: id, version: expectedVersion }, { $set: { field: value, version: expectedVersion + 1 } });
  } else {
    console.error("Write conflict detected.");
  }
  ```

75. **Як працює механізм блокувань у MongoDB?**
    Механізм блокувань у MongoDB забезпечує координацію доступу до даних для уникнення конфліктів і забезпечення консистентності даних. MongoDB використовує кілька рівнів блокувань:
- **Глобальні блокування (Global Locks):** Забезпечують блокування на рівні всієї бази даних.
- **Блокування бази даних (Database Locks):** Забезпечують блокування на рівні окремої бази даних.
- **Блокування колекцій (Collection Locks):** Забезпечують блокування на рівні окремої колекції.
- **Блокування документів (Document Locks):** Забезпечують блокування на рівні окремого документа.

Механізм блокувань MongoDB забезпечує координацію доступу до даних і уникнення конфліктів при виконанні операцій запису і читання. Блокування можуть бути читання/запису (read/write) або тільки читання (read-only), що дозволяє оптимізувати доступ до даних.

76. **Що таке "two-phase commits" і як їх використовувати?**
    Двофазні коміти (two-phase commits) у MongoDB забезпечують атомарність транзакцій, що охоплюють кілька колекцій або баз даних. Процес двофазного коміту включає два етапи:
1. **Підготовка (Prepare):** Всі учасники транзакції виконують операції і записують журнал змін, але не застосовують зміни.
2. **Коміт (Commit):** Після успішної підготовки всі учасники застосовують зміни.

Використання двофазних комітів забезпечує консистентність даних у розподілених системах і уникнення проблем із частковими оновленнями.

77. **Як працюють "distributed transactions" у MongoDB?**
    Розподілені транзакції у MongoDB дозволяють виконувати атомарні операції на кількох шардованих кластерах або реплікаційних наборах. Вони забезпечують підтримку ACID властивостей для транзакцій, що охоплюють кілька баз даних або колекцій. Основні кроки роботи з розподіленими транзакціями:
1. **Початок сесії:** Використання методу `startSession()`.
   ```javascript
   const session = client.startSession();
   ```
2. **Початок транзакції:** Використання методу `startTransaction()`.
   ```javascript
   session.startTransaction();
   ```
3. **Виконання операцій:** Виконання операцій запису в рамках транзакції на кількох колекціях або базах даних.
   ```javascript
   db.collection1.insertOne({ name: "Alice" }, { session });
   db.collection2.updateOne({ name: "Alice" }, { $set: { age: 30 } }, { session });
   ```
4. **Коміт або відкат:** Завершення транзакції за допомогою методів `commitTransaction()` або `abortTransaction()`.
   ```javascript
   session.commitTransaction();
   session.endSession();
   ```

78. **Що таке "session" і як її використовувати у транзакціях?**
    Сесії (sessions) у MongoDB забезпечують контекст для виконання транзакцій і дозволяють групувати кілька операцій у одну атомарну операцію. Використання сесій включає наступні кроки:
1. **Початок сесії:** Використання методу `startSession()`.
   ```javascript
   const session = client.startSession();
   ```
2. **Виконання операцій у рамках сесії:** Виконання операцій запису або читання, передаючи сесію як параметр.
   ```javascript
   db.collection.insertOne({ name: "Alice" }, { session });
   db.collection.updateOne({ name: "Alice" }, { $set: { age: 30 } }, { session });
   ```
3. **Завершення сесії:** Закриття сесії після завершення операцій.
   ```javascript
   session.endSession();
   ```

79. **Як налаштувати "timeouts" для транзакцій у MongoDB?**
    Налаштування таймаутів для транзакцій у MongoDB дозволяє контролювати максимальний час виконання транзакцій, щоб уникнути блокувань і підвищення навантаження на систему. Таймаути налаштовуються за допомогою параметра `maxTransactionLockRequestTimeoutMillis` при створенні кластера або конфігурації бази даних. Приклад налаштування таймауту:
   ```shell
   mongod --maxTransactionLockRequestTimeoutMillis 60000
   ```
Це налаштування встановлює максимальний час очікування блокування для транзакцій на 60 секунд.

80. **Що таке "journaling" і як він працює у MongoDB?**
    Журналювання (journaling) у MongoDB забезпечує надійність даних, записуючи всі операції запису у журнал перед їх застосуванням до бази даних. Це дозволяє відновлювати дані у разі збоїв або аварійного завершення роботи. Журналювання включає два основні компоненти:
- **Журнальні файли:** Файли, що зберігають журнали змін.
- **Журнальні записи:** Записи про операції, які включають інформацію про змінені документи і операції.

Журналювання дозволяє забезпечити консистентність даних і відновлення після збоїв. Вмикання журналювання у MongoDB:
   ```shell
   mongod --journal
   ```

81. **Як налаштувати "journaling" для підвищення надійності?**
    Для налаштування журналювання у MongoDB і підвищення надійності даних необхідно використовувати параметр `--journal` при запуску MongoDB. Це забезпечить запис всіх операцій у журнал перед їх застосуванням до бази даних. Приклад налаштування:
   ```shell
   mongod --journal
   ```
Додаткові параметри журналювання включають:
- **journalCommitInterval:** Інтервал у мілісекундах між комітами журналу.
  ```shell
  mongod --journalCommitInterval 100
  ```
Ці параметри дозволяють налаштувати поведінку журналювання і забезпечити високу надійність даних у разі збоїв.

82. **Що таке "mongodump" і "mongorestore"?**
    `mongodump` і `mongorestore` — це інструменти командного рядка для створення резервних копій і відновлення баз даних у MongoDB.
- **mongodump:** Створює резервну копію бази даних або окремих колекцій у форматі BSON.
  ```shell
  mongodump --db myDatabase --out /path/to/backup
  ```
- **mongorestore:** Відновлює базу даних або колекції з резервної копії, створеної за допомогою `mongodump`.
  ```shell
  mongorestore --db myDatabase /path/to/backup/myDatabase
  ```
Ці інструменти забезпечують просте і ефективне створення резервних копій і відновлення даних у MongoDB.

83. **Як виконувати резервне копіювання у MongoDB?**
    Резервне копіювання у MongoDB виконується за допомогою інструментів `mongodump` або функціональності MongoDB Atlas для створення автоматизованих резервних копій. Приклад використання `mongodump` для створення резервної копії бази даних:
   ```shell
   mongodump --db myDatabase --out /path/to/backup
   ```
Це створить резервну копію

бази даних `myDatabase` у вказаній директорії. Для автоматизованого резервного копіювання у MongoDB Atlas можна налаштувати політики резервного копіювання через консоль керування.

84. **Як відновлювати дані з резервних копій у MongoDB?**
    Відновлення даних з резервних копій у MongoDB виконується за допомогою інструменту `mongorestore`, який відновлює базу даних або колекції з резервної копії, створеної за допомогою `mongodump`. Приклад використання `mongorestore` для відновлення бази даних:
   ```shell
   mongorestore --db myDatabase /path/to/backup/myDatabase
   ```
Це відновить базу даних `myDatabase` з резервної копії, збереженої у вказаній директорії.

85. **Що таке "point-in-time recovery" і як його виконувати?**
    "Point-in-time recovery" (PITR) у MongoDB дозволяє відновлювати дані до певного моменту часу, використовуючи журнали змін (oplog) реплікаційного набору. Це забезпечує гнучкість у відновленні даних у разі помилок або збоїв. Основні кроки для виконання PITR:
1. **Створення базової резервної копії:** Використання `mongodump` для створення резервної копії бази даних.
   ```shell
   mongodump --db myDatabase --out /path/to/backup
   ```
2. **Зберігання журналів змін (oplog):** Використання параметра `--oplog` при створенні резервної копії для збереження журналів змін.
   ```shell
   mongodump --db myDatabase --out /path/to/backup --oplog
   ```
3. **Відновлення базової резервної копії:** Використання `mongorestore` для відновлення базової резервної копії.
   ```shell
   mongorestore --db myDatabase /path/to/backup/myDatabase
   ```
4. **Відновлення змін з журналів:** Використання журналів змін для відновлення даних до певного моменту часу.
   ```shell
   mongorestore --oplogReplay /path/to/backup/oplog.bson
   ```

86. **Як налаштувати моніторинг продуктивності MongoDB?**
    Для налаштування моніторингу продуктивності MongoDB можна використовувати кілька інструментів і методів:
- **MongoDB Atlas:** Вбудовані засоби моніторингу і аналізу продуктивності, доступні через консоль керування.
- **Cloud Manager:** Інструмент для моніторингу, резервного копіювання і управління MongoDB кластерами.
- **Ops Manager:** Локальне рішення для моніторингу, резервного копіювання і управління MongoDB кластерами.
- **Профайлер запитів:** Використання вбудованого профайлера для відстеження і аналізу виконання запитів.
  ```javascript
  db.setProfilingLevel(2);
  db.system.profile.find().sort({ ts: -1 }).limit(5).pretty();
  ```
Ці інструменти дозволяють відстежувати продуктивність бази даних, виявляти вузькі місця і оптимізувати роботу MongoDB.

87. **Що таке "mongostat" і як його використовувати?**
    `mongostat` — це інструмент командного рядка, який показує статистику роботи MongoDB у режимі реального часу. Він відображає інформацію про продуктивність, використання ресурсів і активність бази даних. Приклад використання `mongostat`:
   ```shell
   mongostat --host localhost --port 27017
   ```
Вивід `mongostat` включає такі показники, як кількість операцій запису і читання, використання пам'яті, активність журналювання та інші метрики. Це дозволяє моніторити продуктивність MongoDB у режимі реального часу і виявляти проблеми.

88. **Як використовувати "mongotop" для моніторингу?**
    `mongotop` — це інструмент командного рядка для моніторингу використання часу процесора і вводу/виводу для кожної колекції у MongoDB. Він показує, скільки часу витрачається на читання і запис у кожну колекцію. Приклад використання `mongotop`:
   ```shell
   mongotop --host localhost --port 27017
   ```
Вивід `mongotop` включає інформацію про використання часу процесора і вводу/виводу для кожної колекції, що дозволяє ідентифікувати колекції з високою активністю і оптимізувати їх роботу.

89. **Як налаштувати і використовувати "Ops Manager"?**
    Ops Manager — це локальне рішення для моніторингу, резервного копіювання і управління MongoDB кластерами. Основні кроки налаштування і використання Ops Manager:
1. **Встановлення Ops Manager:** Завантаження і встановлення Ops Manager на сервері.
2. **Налаштування бази даних Ops Manager:** Створення бази даних для Ops Manager.
3. **Налаштування агентів:** Встановлення і налаштування агентів для моніторингу і резервного копіювання MongoDB кластерів.
4. **Підключення MongoDB кластерів:** Додавання MongoDB кластерів у консоль керування Ops Manager.
5. **Моніторинг і управління:** Використання консолі керування для моніторингу продуктивності, управління конфігурацією і створення резервних копій.

Ops Manager надає інструменти для моніторингу, аналізу продуктивності, управління конфігурацією і забезпечення надійності даних у MongoDB кластерах.

90. **Що таке "Atlas Data Lake" і як його використовувати?**
    Atlas Data Lake — це керований сервіс MongoDB Atlas для зберігання і аналізу великих обсягів даних, зберігаючи їх у форматі JSON, BSON, CSV, TSV або Avro. Основні кроки використання Atlas Data Lake:
1. **Створення Data Lake:** Створення нового Data Lake у консолі керування MongoDB Atlas.
2. **Підключення джерел даних:** Додавання джерел даних, таких як Amazon S3, для зберігання даних.
3. **Налаштування Data Lake:** Конфігурація шляху до даних, схем і політик доступу.
4. **Виконання запитів:** Використання стандартних MongoDB запитів для аналізу даних у Data Lake.

Atlas Data Lake забезпечує простий і ефективний спосіб зберігання і аналізу великих обсягів даних, інтегруючись з іншими сервісами MongoDB Atlas.

91. **Як обробляти великі обсяги даних у MongoDB?**
    Обробка великих обсягів даних у MongoDB включає використання кількох стратегій і методів:
- **Шардинг:** Горизонтальне масштабування даних за допомогою розподілу їх між кількома шард.
- **Індекси:** Створення індексів для прискорення запитів і зниження часу сканування колекцій.
- **Агрегаційний фреймворк:** Використання агрегаційного "pipeline" для обробки і аналізу великих обсягів даних.
- **Капітальні колекції:** Використання капітальних колекцій для зберігання обмеженого обсягу даних, що автоматично видаляються після досягнення певного розміру.
- **TTL індекси:** Використання індексів з обмеженим терміном життя для автоматичного видалення старих документів.
- **GridFS:** Зберігання і обробка великих файлів за допомогою GridFS.
  Ці методи дозволяють ефективно обробляти і аналізувати великі обсяги даних у MongoDB.

92. **Що таке "MapReduce" і як його використовувати у MongoDB?**
    `MapReduce` у MongoDB — це модель обробки даних, яка використовується для виконання складних агрегацій і обчислень над великими обсягами даних. Вона

складається з двох етапів: `map` (перетворення даних) і `reduce` (агрегація результатів). Приклад використання `MapReduce` для підрахунку кількості замовлень кожного користувача:
   ```javascript
   db.orders.mapReduce(
     function() {
       emit(this.userId, 1);
     },
     function(key, values) {
       return Array.sum(values);
     },
     {
       out: "orderCounts"
     }
   );
   ```
У цьому прикладі функція `map` еммітує ключ-значення для кожного замовлення, де ключ — це `userId`, а значення — 1. Функція `reduce` сумує значення для кожного користувача, підраховуючи кількість замовлень.

93. **Як використовувати агрегаційний фреймворк для аналізу даних?**
    Агрегаційний фреймворк у MongoDB дозволяє виконувати складні операції над даними за допомогою "pipeline", який складається з послідовності етапів (stages). Основні етапи агрегації включають:
- **$match:** Фільтрація документів на основі умов.
- **$group:** Групування документів і обчислення агрегатних значень.
- **$project:** Перетворення документів і вибір полів.
- **$sort:** Сортування документів.
- **$limit:** Обмеження кількості результатів.
- **$unwind:** Розгортання масивів у документи.

Приклад агрегаційного запиту для аналізу продажів:
   ```javascript
   db.sales.aggregate([
     { $match: { status: "completed" } },
     { $group: { _id: "$productId", totalSales: { $sum: "$amount" } } },
     { $sort: { totalSales: -1 } },
     { $limit: 10 }
   ]);
   ```
У цьому прикладі "pipeline" складається з чотирьох етапів: фільтрація завершених продажів, групування за продуктом, сортування за загальною сумою продажів і обмеження результатів до 10 найпопулярніших продуктів.

94. **Як оптимізувати агрегаційні запити у MongoDB?**
    Оптимізація агрегаційних запитів у MongoDB включає кілька підходів:
- **Використання індексів:** Створення індексів для полів, які використовуються у етапі `$match`, для прискорення фільтрації.
  ```javascript
  db.collection.createIndex({ status: 1, productId: 1 });
  ```
- **Фільтрація на ранніх етапах:** Використання `$match` на початку "pipeline" для зменшення обсягу даних, які проходять через наступні етапи.
- **Проекція необхідних полів:** Використання `$project` для вибору тільки необхідних полів, зменшуючи розмір документів.
  ```javascript
  db.collection.aggregate([
    { $project: { field1: 1, field2: 1 } }
  ]);
  ```
- **Аналіз і оптимізація плану виконання:** Використання методу `explain()` для аналізу плану виконання агрегаційного запиту і внесення змін для покращення продуктивності.
  ```javascript
  db.collection.aggregate([...]).explain("executionStats");
  ```

Ці підходи допомагають підвищити ефективність і швидкість виконання агрегаційних запитів у MongoDB.

95. **Як налаштувати масштабування у MongoDB?**
    Масштабування у MongoDB може бути вертикальним (збільшення ресурсів одного сервера) або горизонтальним (додавання нових серверів). Основні методи горизонтального масштабування:
- **Шардинг:** Розподіл даних між кількома шард, що дозволяє розподілити навантаження і забезпечити високу продуктивність.
    1. **Включення шардингу для бази даних:**
       ```javascript
       sh.enableSharding("myDatabase");
       ```
    2. **Вибір ключа шардингу для колекції:**
       ```javascript
       sh.shardCollection("myDatabase.myCollection", { shardKey: 1 });
       ```

- **Реплікація:** Використання реплікаційних наборів для підвищення доступності і надійності даних.
    1. **Ініціалізація реплікаційного набору:**
       ```shell
       mongod --replSet "rs0"
       ```
    2. **Конфігурація реплікаційного набору:**
       ```javascript
       rs.initiate({
         _id: "rs0",
         members: [
           { _id: 0, host: "host1:27017" },
           { _id: 1, host: "host2:27017" },
           { _id: 2, host: "host3:27017" }
         ]
       });
       ```

96. **Що таке "mongos" і як його використовувати?**
    `mongos` — це маршрутизатор шардингу у MongoDB, який управляє розподілом запитів між шард у шардованому кластері. `mongos` приймає запити від клієнтів і направляє їх до відповідних шард на основі метаданих про розподіл даних. Основні кроки налаштування `mongos`:
1. **Запуск `mongos`:** Запуск `mongos` з параметрами підключення до конфігураційних серверів.
   ```shell
   mongos --configdb configReplSet/host1:27019,host2:27019,host3:27019
   ```
2. **Підключення клієнтів:** Підключення клієнтів до `mongos` для виконання запитів.
   ```javascript
   const MongoClient = require('mongodb').MongoClient;
   MongoClient.connect('mongodb://mongos_host:27017', { useNewUrlParser: true, useUnifiedTopology: true }, function(err, client) {
     const db = client.db('myDatabase');
     // Виконання операцій з базою даних
   });
   ```
`mongos` забезпечує розподіл навантаження і високий рівень продуктивності у шардованих кластерах MongoDB.

97. **Як налаштувати і використовувати "sharding" у MongoDB?**
    Налаштування і використання шардингу у MongoDB включає кілька кроків:
1. **Налаштування конфігураційних серверів:** Створення реплікаційного набору конфігураційних серверів для зберігання метаданих про розподіл даних.
   ```shell
   mongod --configsvr --replSet configReplSet --port 27019 --dbpath /data/configdb
   ```
2. **Ініціалізація конфігураційного реплікаційного набору:**
   ```javascript
   rs.initiate({
     _id: "configReplSet",
     members: [
       { _id: 0, host: "host1:27019" },
       { _id: 1, host: "host2:27019" },
       { _id: 2, host: "host3:27019" }
     ]
   });
   ```
3. **Запуск `mongos`:** Запуск `mongos` з підключенням до конфігураційних серверів.
   ```shell
   mongos --configdb configReplSet/host1:27019,host2:27019,host3:27019
   ```
4. **Включення шардингу для бази даних і вибір ключа шардингу для колекцій:**
   ```javascript
   sh.enableSharding("myDatabase");
   sh.shardCollection("myDatabase.myCollection", { shardKey: 1 });
   ```
Шардинг дозволяє горизонтально масштабувати базу даних, розподіляючи дані між кількома шард і забезпечуючи високу продуктивність.

98. **Як працює "chunking" у MongoDB?**
    "Chunking" у MongoDB — це процес розподілу даних на частини (chunks) у шардованих кластерах. Кожна частина містить підмножину даних і зберігається на окремому шарді. Це дозволяє розподіляти навантаження між кількома шард і забезпечити високу продуктивність. Основні етапи chunking:
- **Розподіл даних:** Дані розподі

ляються на частини на основі ключа шардингу.
- **Міграція частин:** Частини можуть мігрувати між шард для забезпечення балансу навантаження.
- **Балансування:** Процес балансування забезпечує рівномірний розподіл даних між шард.

Конфігурація chunking виконується автоматично, але може бути налаштована для специфічних вимог.

99. **Як налаштувати "balancer" у MongoDB?**
    Балансувальник (balancer) у MongoDB забезпечує рівномірний розподіл даних між шард у шардованому кластері. Він автоматично мігрує частини між шард для забезпечення балансу навантаження. Основні кроки налаштування балансувальника:
1. **Запуск `mongos`:** Запуск маршрутизатора `mongos` для керування шардованим кластером.
   ```shell
   mongos --configdb configReplSet/host1:27019,host2:27019,host3:27019
   ```
2. **Включення балансувальника:** Включення або вимкнення балансувальника за допомогою командного рядка `sh`.
   ```javascript
   sh.startBalancer();
   sh.stopBalancer();
   ```
3. **Моніторинг стану балансувальника:** Перевірка стану балансувальника за допомогою команди `sh.getBalancerState()`.
   ```javascript
   sh.getBalancerState();
   ```
Балансувальник автоматично забезпечує рівномірний розподіл даних між шард для підтримання високої продуктивності.

100. **Як налаштувати "tag-aware sharding" у MongoDB?**
     "Tag-aware sharding" у MongoDB дозволяє керувати розподілом даних між шард на основі тегів. Це дозволяє зберігати дані у певних географічних регіонах або на певних серверах. Основні кроки налаштування "tag-aware sharding":
     1. **Визначення діапазонів тегів:** Створення тегів і визначення діапазонів для кожного тегу.
       ```javascript
       sh.addShardTag("shard1", "regionA");
       sh.addShardTag("shard2", "regionB");
       sh.addTagRange("myDatabase.myCollection", { shardKey: MinKey }, { shardKey: MaxKey }, "regionA");
       ```
    2. **Налаштування політики розподілу даних:** Визначення політики розподілу даних на основі тегів.
       ```javascript
       sh.updateZoneKeyRange("myDatabase.myCollection", { shardKey: 1 }, { shardKey: 100 }, "regionA");
       sh.updateZoneKeyRange("myDatabase.myCollection", { shardKey: 101 }, { shardKey: 200 }, "regionB");
       ```
    3. **Моніторинг і управління:** Використання команд для моніторингу і управління розподілом даних на основі тегів.
       ```javascript
       sh.status();
       ```
    "Tag-aware sharding" дозволяє забезпечити гнучкий і контрольований розподіл даних у шардованих кластерах MongoDB.

101. **Що таке "indexing strategies" у MongoDB?**
     Індексаційні стратегії у MongoDB включають різні методи створення індексів для підвищення продуктивності запитів. Основні стратегії включають:
     - **Однопольові індекси (Single Field Indexes):** Індекси для одного поля.
      ```javascript
      db.collection.createIndex({ field: 1 });
      ```
    - **Складені індекси (Compound Indexes):** Індекси для кількох полів.
      ```javascript
      db.collection.createIndex({ field1: 1, field2: -1 });
      ```
    - **Мультіключові індекси (Multikey Indexes):** Індекси для полів, що містять масиви.
      ```javascript
      db.collection.createIndex({ arrayField: 1 });
      ```
    - **Текстові індекси (Text Indexes):** Індекси для текстових пошуків.
      ```javascript
      db.collection.createIndex({ field: "text" });
      ```
    - **Геопросторові індекси (Geospatial Indexes):** Індекси для географічних даних.
      ```javascript
      db.collection.createIndex({ location: "2dsphere" });
      ```
    - **Хешовані індекси (Hashed Indexes):** Індекси для полів, значення яких розподіляються випадково.
      ```javascript
      db.collection.createIndex({ field: "hashed" });
      ```
    Вибір стратегії індексації залежить від характеру запитів і структури даних.

102. **Як використовувати геоіндекси для пошуку у MongoDB?**
     Геоіндекси у MongoDB використовуються для зберігання і запитів географічних даних. Основні типи геоіндексів включають 2d індекси для двовимірних координат і 2dsphere індекси для сферичних координат. Приклад використання 2dsphere індексу:
     ```javascript
     db.places.createIndex({ location: "2dsphere" });
     ```
     Пошук найближчих точок:
     ```javascript
     db.places.find({ location: { $near: { $geometry: { type: "Point", coordinates: [50, 50] }, $maxDistance: 1000 } } });
     ```
     Геоіндекси дозволяють ефективно виконувати запити на основі географічних координат, такі як пошук найближчих точок, області або радіуса.

103. **Що таке "text search" і як його налаштувати у MongoDB?**
     Текстовий пошук у MongoDB дозволяє виконувати повнотекстові пошуки за текстовими полями у документах. Для налаштування текстового пошуку створюється текстовий індекс:
     ```javascript
     db.articles.createIndex({ content: "text" });
     ```
     Виконання текстового пошуку:
     ```javascript
     db.articles.find({ $text: { $search: "MongoDB" } });
     ```
     Текстові індекси підтримують кілька функцій, таких як пошук фраз, виключення слів і вагові пошуки. Приклад пошуку фраз:
     ```javascript
     db.articles.find({ $text: { $search: "\"NoSQL database\"" } });
     ```

104. **Як налаштувати і використовувати текстові індекси у MongoDB?**
     Для налаштування текстових індексів у MongoDB використовується метод `createIndex()`, який приймає параметр "text". Приклад створення текстового індексу:
     ```javascript
     db.articles.createIndex({ content: "text" });
     ```
     Текстові індекси дозволяють виконувати повнотекстові пошуки за текстовими полями у документах. Виконання текстового пошуку:
     ```javascript
     db.articles.find({ $text: { $search: "MongoDB" } });
     ```
     Текстові індекси підтримують кілька функцій, таких як пошук фраз, виключення слів і вагові пошуки. Приклад пошуку фраз:
     ```javascript
     db.articles.find({ $text: { $search: "\"NoSQL database\"" } });
     ```
     Текстові індекси дозволяють ефективно виконувати пошуки за текстовими полями і забезпечують гнучкість у налаштуванні пошукових запитів.

105. **Що таке "hashed indexes" і як їх використовувати?**
     Хешовані індекси (hashed indexes) у MongoDB використовуються для рівномірного розподілу значень поля шляхом застосування хеш-функції. Це дозволяє забезпечити рівномірний розподіл даних і підвищити продуктивність запитів. Приклад створення хешованого індексу:
     ```javascript
     db.collection.createIndex({ field: "hashed" });
     ```
     Хешовані індекси корисні для полів з нерівномірно розподіленими значеннями, оскільки вони забезпечують більш рівномірний розподіл даних у індексі.

106. **Як використовувати TTL індекси для керування життєвим циклом даних?**
     TTL індекси (Time To Live) у MongoDB використовуються для автоматичного видалення документів після закінчення пев

ного часу. Це корисно для керування життєвим циклом даних, наприклад, для видалення застарілих записів або журналів. TTL індекси створюються з параметром `expireAfterSeconds`, який визначає час життя документа в секундах. Приклад створення TTL індексу:
```javascript
db.session.createIndex({ createdAt: 1 }, { expireAfterSeconds: 3600 });
```
У цьому прикладі документи у колекції `session` будуть автоматично видалені через 1 годину після створення.

107. **Що таке "wildcard indexes" і як їх використовувати?**
     Wildcard індекси у MongoDB дозволяють індексувати всі поля документа або підмножину полів за допомогою шаблонів. Це забезпечує гнучкість і спрощує індексацію динамічних або неструктурованих даних. Приклад створення wildcard індексу для всіх полів:
     ```javascript
     db.collection.createIndex({ "$**": 1 });
     ```
     Приклад створення wildcard індексу для підмножини полів:
     ```javascript
     db.collection.createIndex({ "prefix.*": 1 });
     ```
     Wildcard індекси дозволяють автоматично індексувати нові поля, що додаються до документів, забезпечуючи ефективний пошук у неструктурованих даних.

108. **Що таке "collation" і як його використовувати у MongoDB?**
     Collation у MongoDB визначає правила порівняння і сортування рядків для запитів, включаючи регістр, діакритичні знаки і інші мовні особливості. Collation можна застосовувати на рівні колекції, індексу або запиту. Приклад створення колекції з collation:
     ```javascript
     db.createCollection("myCollection", { collation: { locale: "en", strength: 2 } });
     ```
     Приклад створення індексу з collation:
     ```javascript
     db.collection.createIndex({ field: 1 }, { collation: { locale: "en", strength: 2 } });
     ```
     Приклад використання collation у запиті:
     ```javascript
     db.collection.find({ field: "value" }).collation({ locale: "en", strength: 2 });
     ```
     Collation дозволяє забезпечити правильне сортування і порівняння рядків для різних мов і культурних контекстів.

109. **Як налаштувати "collation" для запитів у MongoDB?**
     Collation у MongoDB визначає правила порівняння і сортування рядків для запитів. Collation можна налаштовувати на рівні колекції, індексу або окремого запиту. Приклад створення колекції з collation:
     ```javascript
     db.createCollection("myCollection", { collation: { locale: "en", strength: 2 } });
     ```
     Приклад створення індексу з collation:
     ```javascript
     db.collection.createIndex({ field: 1 }, { collation: { locale: "en", strength: 2 } });
     ```
     Приклад використання collation у запиті:
     ```javascript
     db.collection.find({ field: "value" }).collation({ locale: "en", strength: 2 });
     ```
     Collation дозволяє забезпечити правильне сортування і порівняння рядків для різних мов і культурних контекстів.

110. **Що таке "aggregation pipelines" і як їх використовувати у MongoDB?**
     Агрегаційні "pipelines" у MongoDB дозволяють виконувати складні операції над даними за допомогою послідовності етапів (stages). Кожен етап виконує певну операцію, таку як фільтрація, групування, сортування або перетворення. Приклад агрегаційного "pipeline":
     ```javascript
     db.orders.aggregate([
     { $match: { status: "completed" } },
     { $group: { _id: "$customerId", totalAmount: { $sum: "$amount" } } },
     { $sort: { totalAmount: -1 } },
     { $limit: 10 }
     ]);
     ```
     У цьому прикладі "pipeline" складається з чотирьох етапів: фільтрація документів за статусом, групування за клієнтом, сортування за загальною сумою і обмеження кількості результатів.

111. **Як працює оператор $lookup у агрегаціях MongoDB?**
     Оператор `$lookup` у MongoDB використовується для об'єднання (join) даних з різних колекцій у процесі агрегації. Це дозволяє виконувати запити, що об'єднують документи на основі певного критерію. Приклад використання `$lookup` для об'єднання колекцій `orders` і `users`:
     ```javascript
     db.orders.aggregate([
     {
     $lookup: {
     from: "users",
     localField: "userId",
     foreignField: "_id",
     as: "userDetails"
     }
     }
     ]);
     ```
     У цьому прикладі всі документи з колекції `orders` будуть об'єднані з відповідними документами з колекції `users` на основі поля `userId`.

112. **Що таке "facet" у агрегаційному фреймворку MongoDB?**
     Оператор `$facet` у агрегаційному фреймворку MongoDB дозволяє виконувати кілька незалежних "pipelines" паралельно і об'єднувати їх результати в один документ. Це корисно для виконання складних багатовимірних аналізів даних. Приклад використання `$facet`:
     ```javascript
     db.sales.aggregate([
     {
     $facet: {
     totalSales: [
     { $group: { _id: null, total: { $sum: "$amount" } } }
     ],
     salesByCategory: [
     { $group: { _id: "$category", total: { $sum: "$amount" } } }
     ],
     salesByRegion: [
     { $group: { _id: "$region", total: { $sum: "$amount" } } }
     ]
     }
     }
     ]);
     ```
     У цьому прикладі три незалежні "pipelines" обчислюють загальні продажі, продажі за категоріями і продажі за регіонами, і результати об'єднуються в один документ.

113. **Як працює оператор $bucket у агрегаціях MongoDB?**
     Оператор `$bucket` у агрегаціях MongoDB використовується для групування документів у фіксовану кількість діапазонів (bucket) на основі значень поля. Це дозволяє виконувати розподілені обчислення, такі як гістограми. Приклад використання `$bucket`:
     ```javascript
     db.sales.aggregate([
     {
     $bucket: {
     groupBy: "$amount",
     boundaries: [0, 100, 200, 300, 400],
     default: "Other",
     output: {
     count: { $sum: 1 },
     totalAmount: { $sum: "$amount" }
     }
     }
     }
     ]);
     ```
     У цьому прикладі документи групуються у чотири діапазони значень `amount`, і для кожного діапазону обчислюється кількість документів і загальна сума.

114. **Як працює оператор $unwind у агрегаціях MongoDB?**
     Оператор `$unwind` у агрегаціях MongoDB використовується для розгортання масивів у документи. Кожен елемент масиву перетворюється на окремий документ. Це корисно для обробки даних, що містять масиви. Приклад використання `$unwind`:
     ```javascript
     db.orders.aggregate([
     { $unwind: "$items" },
     { $group: { _id: "$customerId", totalItems: { $sum: 1 }, totalAmount: { $sum: "$items.price" } } }
     ]);
     ```
     У цьому прикладі масив `items` розгортається, після чого документи групуються за `customerId`, обчислюється загальна кількість товарів і сума цін.

115. **Що таке "materialized views" і як їх використовувати у MongoDB?**
     Матеріалізовані представлення (materialized views) у MongoDB — це збережені результати агрегацій, які оновлюються у режимі реального часу. Вони дозволяють швидко отримувати результати складних запитів без необхідності виконання агрегацій щоразу. Основні кроки створення матеріалізованого представлення:
     1. **Створення

колекції для збереження результатів агрегації:**
```javascript
db.createCollection("salesSummary");
```
2. **Виконання агрегації і збереження результатів:**
```javascript
db.sales.aggregate([
{ $group: { _id: "$category", totalSales: { $sum: "$amount" } } },
{ $out: "salesSummary" }
]);
```
3. **Налаштування тригерів або `change streams` для автоматичного оновлення:**
```javascript
const changeStream = db.sales.watch();
changeStream.on("change", function(change) {
// Оновлення матеріалізованого представлення
});
```
Матеріалізовані представлення забезпечують високу продуктивність для складних запитів, які виконуються часто.

116. **Як використовувати "aggregation stages" у MongoDB?**
     Агрегаційні етапи (stages) у MongoDB дозволяють виконувати різні операції над даними у "pipeline". Основні агрегаційні етапи включають:
     - **$match:** Фільтрація документів на основі умов.
      ```javascript
      db.collection.aggregate([{ $match: { field: value } }]);
      ```
    - **$group:** Групування документів і обчислення агрегатних значень.
      ```javascript
      db.collection.aggregate([{ $group: { _id: "$groupField", total: { $sum: "$amount" } } }]);
      ```
    - **$project:** Перетворення документів і вибір полів.
      ```javascript
      db.collection.aggregate([{ $project: { field1: 1, field2: 1 } }]);
      ```
    - **$sort:** Сортування документів.
      ```javascript
      db.collection.aggregate([{ $sort: { field: 1 } }]);
      ```
    - **$limit:** Обмеження кількості результатів.
      ```javascript
      db.collection.aggregate([{ $limit: 10 } }]);
      ```
    Агрегаційні етапи дозволяють виконувати складні обчислення і перетворення даних у "pipeline".

117. **Що таке "aggregation framework" у MongoDB?**
     Агрегаційний фреймворк у MongoDB — це потужний інструмент для виконання складних операцій над даними, таких як фільтрація, групування, сортування і перетворення. Фреймворк базується на "pipeline", який складається з послідовності етапів (stages). Основні етапи агрегаційного фреймворку:
     - **$match:** Фільтрація документів на основі умов.
     - **$group:** Групування документів і обчислення агрегатних значень.
     - **$project:** Перетворення документів і вибір полів.
     - **$sort:** Сортування документів.
     - **$limit:** Обмеження кількості результатів.
     - **$unwind:** Розгортання масивів у документи.

    Приклад агрегаційного запиту:
    ```javascript
    db.sales.aggregate([
      { $match: { status: "completed" } },
      { $group: { _id: "$productId", totalSales: { $sum: "$amount" } } },
      { $sort: { totalSales: -1 } },
      { $limit: 10 }
    ]);
    ```
    Агрегаційний фреймворк дозволяє виконувати складні операції над даними у MongoDB.

118. **Як працює "pipeline" у агрегаціях MongoDB?**
     "Pipeline" у агрегаціях MongoDB — це послідовність етапів (stages), які виконуються над даними для їх обробки і аналізу. Кожен етап виконує певну операцію, таку як фільтрація, групування, сортування або перетворення. Етапи виконуються послідовно, передаючи результати з одного етапу до наступного. Приклад агрегаційного "pipeline":
     ```javascript
     db.orders.aggregate([
     { $match: { status: "completed" } },
     { $group: { _id: "$customerId", totalAmount: { $sum: "$amount" } } },
     { $sort: { totalAmount: -1 } },
     { $limit: 10 }
     ]);
     ```
     У цьому прикладі "pipeline" складається з чотирьох етапів: фільтрація завершених замовлень, групування за клієнтом, сортування за загальною сумою і обмеження результатів до 10 найактивніших клієнтів.

119. **Що таке "change streams" у MongoDB?**
     "Change streams" у MongoDB дозволяють відстежувати зміни у колекціях і базах даних у режимі реального часу. Вони використовуються для обробки подій, що виникають при вставці, оновленні або видаленні документів. Приклад створення "change stream":
     ```javascript
     const MongoClient = require('mongodb').MongoClient;

    MongoClient.connect('mongodb://localhost:27017', { useNewUrlParser: true, useUnifiedTopology: true }, function(err, client) {
      const db = client.db('myDatabase');
      const changeStream = db.collection('myCollection').watch();

      changeStream.on('change', function(change) {
        console.log('Change detected:', change);
      });
    });
    ```
    "Change streams" можна використовувати для різних задач, таких як синхронізація даних між базами даних, обробка подій у реальному часі або побудова реактивних додатків.

120. **Як налаштувати і використовувати "change streams" у MongoDB?**
     Для налаштування і використання "change streams" у MongoDB необхідно підключитися до бази даних, створити "change stream" для колекції або бази даних і обробляти події, що виникають при зміні даних. Приклад налаштування "change stream" для колекції:
     ```javascript
     const MongoClient = require('mongodb').MongoClient;

    MongoClient.connect('mongodb://localhost:27017', { useNewUrlParser: true, useUnifiedTopology: true }, function(err, client) {
      const db = client.db('myDatabase');
      const changeStream = db.collection('myCollection').watch();

      changeStream.on('change', function(change) {
        console.log('Change detected:', change);
      });
    });
    ```
    "Change streams" підтримують фільтрацію подій за допомогою агрегаційного "pipeline". Приклад фільтрації подій за типом операції:
    ```javascript
    const changeStream = db.collection('myCollection').watch([
      { $match: { operationType: 'insert' } }
    ]);
    changeStream.on('change', function(change) {
      console.log('Insert detected:', change);
    });
    ```
    "Change streams" дозволяють відстежувати і обробляти зміни даних у MongoDB у режимі реального часу, забезпечуючи високий рівень гнучкості і реактивності додатків.

### BASE

BASE (Basic Availability, Soft state, Eventual consistency) - це модель проектування розподілених систем, яка виступає альтернативою традиційній ACID-моделі (Atomicity, Consistency, Isolation, Durability), що використовується в реляційних базах даних.

#### Основні принципи BASE:

1. **Basic Availability (Основна доступність):**
    - Система повинна забезпечувати основну доступність навіть у разі часткових збоїв. Це означає, що деякі частини системи можуть бути недоступними, але система в цілому продовжує функціонувати.
    - Наприклад, у разі збою окремих вузлів, інші вузли продовжують обслуговувати запити.

2. **Soft State (М’який стан):**
    - Стан системи може змінюватися з часом, навіть без отримання нових введень (через реплікацію даних або асинхронні оновлення).
    - М’який стан означає, що система допускає тимчасову неконсистентність даних.

3. **Eventual Consistency (Кінцева консистентність):**
    - Згодом усі оновлення в системі будуть розповсюджені, і всі копії даних стануть консистентними.
    - Це означає, що після завершення всіх операцій запису всі читачі отримають однакові дані, але під час операцій оновлення можуть існувати неконсистентності.

#### Приклади використання BASE-моделі:

1. **NoSQL бази даних:**
    - Багато NoSQL баз даних, такі як Apache Cassandra, Amazon DynamoDB і MongoDB, слідують моделі BASE для забезпечення високої доступності та масштабованості.
    - Наприклад, у Cassandra дані реплікуються на кілька вузлів, і система забезпечує доступність навіть при збоях, але консистентність даних гарантується лише з часом.

2. **Розподілені файлові системи:**
    - Такі системи, як Amazon S3, використовують BASE-модель для забезпечення доступності та надійності зберігання даних. Дані можуть бути тимчасово неконсистентними між репліками, але зрештою стають узгодженими.

3. **Масштабовані веб-застосунки:**
    - Веб-застосунки з великим навантаженням, як-от соціальні мережі (наприклад, Facebook або Twitter), використовують BASE-модель для забезпечення швидкого доступу до даних і високої доступності.

#### Переваги BASE:

- **Висока доступність:** Система залишається функціональною навіть при збоях окремих компонентів.
- **Масштабованість:** Підтримка великої кількості операцій завдяки розподілу навантаження між вузлами.
- **Гнучкість:** Підтримка динамічних змін даних і адаптація до змін в навантаженні.

#### Недоліки BASE:

- **Тимчасова неконсистентність:** Дані можуть бути неконсистентними між різними репліками до моменту досягнення кінцевої консистентності.
- **Складність управління:** Необхідність управління асинхронними оновленнями і забезпеченням кінцевої консистентності може додавати складність в проектування і підтримку системи.
- **Затримка у консистентності:** Може виникати затримка перед тим, як дані стануть консистентними, що може бути неприйнятним для деяких застосунків.

BASE-модель є ключовим компонентом для побудови масштабованих і надійних розподілених систем, де основною метою є забезпечення доступності та гнучкості, навіть якщо це означає тимчасову неконсистентність даних.
